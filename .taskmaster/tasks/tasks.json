{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Setup Raspberry Pi with Docker Environment",
        "description": "Install and configure Docker and Docker Compose on the Raspberry Pi to serve as the foundation for all containerized services.",
        "details": "1. Install Raspberry Pi OS (64-bit recommended for better Docker compatibility)\n2. Update system packages: `sudo apt update && sudo apt upgrade -y`\n3. Install Docker: `curl -sSL https://get.docker.com | sh`\n4. Add current user to docker group: `sudo usermod -aG docker $USER`\n5. Install Docker Compose: `sudo apt install -y docker-compose`\n6. Verify installations: `docker --version && docker-compose --version`\n7. Configure Docker to start on boot: `sudo systemctl enable docker`\n8. Create project directory structure:\n```\npower-measurement-service/\n├── docker-compose.yml\n├── .env\n├── mosquitto/\n│   ├── config/\n│   └── data/\n├── mysql/\n│   ├── init.sql\n│   └── data/\n├── flask_app/\n├── vue_app/\n└── ai_llm_module/\n```",
        "testStrategy": "1. Verify Docker is running: `sudo systemctl status docker`\n2. Run a test container: `docker run hello-world`\n3. Create a simple docker-compose.yml with a single service and test with `docker-compose up`\n4. Check system resources to ensure sufficient capacity for all planned containers\n5. Verify network connectivity for the Raspberry Pi",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "Create Docker Compose Configuration",
        "description": "Develop the docker-compose.yml file that defines all required services: MQTT broker, MySQL database, Flask backend, Vue.js frontend, and AI/LLM module.",
        "details": "Create a docker-compose.yml file with the following services:\n\n```yaml\nversion: '3'\n\nservices:\n  mosquitto:\n    image: eclipse-mosquitto:latest\n    ports:\n      - \"1883:1883\"\n      - \"9001:9001\"\n    volumes:\n      - ./mosquitto/config:/mosquitto/config\n      - ./mosquitto/data:/mosquitto/data\n      - ./mosquitto/log:/mosquitto/log\n    restart: always\n\n  mysql:\n    image: mysql:8.0\n    ports:\n      - \"3306:3306\"\n    environment:\n      MYSQL_ROOT_PASSWORD: ${MYSQL_ROOT_PASSWORD}\n      MYSQL_DATABASE: power_measurement\n      MYSQL_USER: ${MYSQL_USER}\n      MYSQL_PASSWORD: ${MYSQL_PASSWORD}\n    volumes:\n      - ./mysql/data:/var/lib/mysql\n      - ./mysql/init.sql:/docker-entrypoint-initdb.d/init.sql\n    restart: always\n\n  flask_app:\n    build: ./flask_app\n    ports:\n      - \"5000:5000\"\n    depends_on:\n      - mysql\n      - mosquitto\n    environment:\n      MYSQL_HOST: mysql\n      MYSQL_USER: ${MYSQL_USER}\n      MYSQL_PASSWORD: ${MYSQL_PASSWORD}\n      MYSQL_DATABASE: power_measurement\n      MQTT_BROKER: mosquitto\n      ANTHROPIC_API_KEY: ${ANTHROPIC_API_KEY}\n    restart: always\n\n  vue_app:\n    build: ./vue_app\n    ports:\n      - \"80:80\"\n    depends_on:\n      - flask_app\n    restart: always\n\n  ai_llm_module:\n    build: ./ai_llm_module\n    depends_on:\n      - mysql\n      - flask_app\n    environment:\n      MYSQL_HOST: mysql\n      MYSQL_USER: ${MYSQL_USER}\n      MYSQL_PASSWORD: ${MYSQL_PASSWORD}\n      MYSQL_DATABASE: power_measurement\n      ANTHROPIC_API_KEY: ${ANTHROPIC_API_KEY}\n    restart: always\n\nvolumes:\n  mysql_data:\n  mosquitto_data:\n```\n\nAlso create a .env file (add to .gitignore) with the following variables:\n```\nMYSQL_ROOT_PASSWORD=secure_root_password\nMYSQL_USER=power_user\nMYSQL_PASSWORD=secure_password\nANTHROPIC_API_KEY=your_ANTHROPIC_API_KEY\n```",
        "testStrategy": "1. Validate docker-compose.yml syntax: `docker-compose config`\n2. Test network configuration by running `docker-compose up -d` and checking if containers can communicate\n3. Verify environment variables are properly passed to containers\n4. Check volume mounts are correctly configured\n5. Ensure all services start without errors\n6. Verify restart policies are set correctly",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Define Service Requirements and Dependencies",
            "description": "List all required services (MQTT broker, MySQL, Flask backend, Vue.js frontend, AI/LLM module) and document their dependencies, ports, and interconnections.",
            "dependencies": [],
            "details": "Identify which services need to communicate with each other, required ports, and any external dependencies. Document these requirements to guide the Compose file structure.\n<info added on 2025-06-27T07:41:29.335Z>\n서비스 요구사항 및 의존성 분석 결과를 다음과 같이 기록합니다:\n\n**서비스 목록:**\n1. `mosquitto`: MQTT 브로커\n2. `mysql`: MySQL 데이터베이스\n3. `flask_app`: Flask 백엔드 서버\n4. `vue_app`: Vue.js 프론트엔드\n5. `ai_llm_module`: AI 모듈\n\n**서비스 간 의존성 (`depends_on`):**\n- `flask_app` -> `mysql`, `mosquitto`\n- `vue_app` -> `flask_app`\n- `ai_llm_module` -> `mysql`, `flask_app`\n\n**포트 매핑 (호스트:컨테이너):**\n- `mosquitto`: `1883:1883`, `9001:9001`\n- `mysql`: `3306:3306`\n- `flask_app`: `5000:5000`\n- `vue_app`: `80:80`\n\n**외부 의존성:**\n- `flask_app`, `ai_llm_module`은 `ANTHROPIC_API_KEY`가 필요합니다.\n</info added on 2025-06-27T07:41:29.335Z>",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Design Network and Volume Structure",
            "description": "Plan and define Docker networks and volumes for service isolation, data persistence, and secure inter-service communication.",
            "dependencies": [
              1
            ],
            "details": "Decide on custom bridge networks for internal communication and named volumes for persistent data (e.g., MySQL data, AI model storage). Document network aliases and volume mount points for each service.\n<info added on 2025-06-27T07:46:01.740Z>\n네트워크 및 볼륨 구조 설계안을 다음과 같이 기록합니다:\n\n**네트워크:**\n- `power-flow-net` 이라는 이름의 사용자 지정 브리지 네트워크를 생성하여 모든 서비스를 연결합니다. 이를 통해 서비스 간 통신을 위한 격리된 환경을 제공합니다.\n\n**볼륨:**\n- **Named Volumes (데이터 지속성):**\n  - `mysql_data`: MySQL 데이터베이스 파일 저장.\n  - `mosquitto_data`: MQTT 브로커의 데이터 (세션, 리테인 메시지 등) 저장.\n- **Bind Mounts (설정/스크립트/로그):**\n  - `./mosquitto/config:/mosquitto/config`: Mosquitto 설정 파일 관리.\n  - `./mosquitto/log:/mosquitto/log`: Mosquitto 로그 파일 접근.\n  - `./mysql/init.sql:/docker-entrypoint-initdb.d/init.sql`: 초기 데이터베이스 스키마 스크립트 실행.\n</info added on 2025-06-27T07:46:01.740Z>",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Draft docker-compose.yml with All Services",
            "description": "Create the initial docker-compose.yml file, specifying each service, its image, build context, ports, volumes, networks, and dependencies.",
            "dependencies": [
              2
            ],
            "details": "Follow best practices: order services alphabetically, group configuration sections logically, and avoid hardcoding sensitive data. Ensure each service is properly configured for networking and volume usage.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Create and Organize .env File(s)",
            "description": "Define all required environment variables for each service in one or more .env files, separating sensitive or environment-specific values from the Compose file.",
            "dependencies": [
              3
            ],
            "details": "List variables such as database credentials, broker URLs, API keys, and service-specific configs. Ensure variables are referenced in docker-compose.yml using the ${VAR_NAME} syntax for maintainability and security.\n<info added on 2025-06-27T07:50:53.695Z>\n- Created the directory structure required for `docker-compose up` including: ai_llm_module, flask_app, vue_app, mosquitto/config, mosquitto/log, and mysql directories.\n- Added an empty `mysql/init.sql` file that will be used for database initialization.\n- Defined essential environment variables in the `.env` file:\n  - MYSQL_ROOT_PASSWORD\n  - MYSQL_DATABASE\n  - MYSQL_USER\n  - MYSQL_PASSWORD\n  - ANTHROPIC_API_KEY\n- Provided examples of these environment variables to the user, who will need to create the actual `.env` file with appropriate values.\n</info added on 2025-06-27T07:50:53.695Z>",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Implement Service-Specific Configuration and Overrides",
            "description": "Add service-specific configuration files or Compose overrides as needed (e.g., for development vs. production), ensuring modularity and clarity.",
            "dependencies": [
              4
            ],
            "details": "Create override files (e.g., docker-compose.override.yml) or service-specific config files for environment-specific settings. Document how to combine files for different deployment scenarios.\n<info added on 2025-06-27T07:54:58.121Z>\nCreated the `mosquitto/config/mosquitto.conf` file with basic configuration settings for the MQTT broker, including message persistence, logging, anonymous access permissions, and listeners for both standard MQTT protocol (port 1883) and WebSocket connections (port 9001).\n</info added on 2025-06-27T07:54:58.121Z>",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Validate, Test, and Document the Setup",
            "description": "Run docker-compose up to validate the configuration, test inter-service communication, and document usage and troubleshooting steps.",
            "dependencies": [
              5
            ],
            "details": "Check that all services start correctly, environment variables are loaded, volumes persist data, and networks allow required communication. Document the setup process, environment variable usage, and common issues.\n<info added on 2025-06-27T10:06:27.673Z>\n테스트 과정에서 발생한 주요 문제점들을 해결했습니다:\n1. Docker 데몬 연결 오류: Docker 서비스가 실행 중인지 확인하고 재시작하여 해결\n2. Dockerfile 누락: 누락된 서비스의 Dockerfile을 생성하고 적절한 베이스 이미지와 설정 추가\n3. 포트 충돌: 이미 사용 중인 포트를 식별하고 docker-compose.yml에서 포트 매핑 수정\n\n모든 문제 해결 후 `docker-compose up -d` 명령을 실행하여 모든 서비스 컨테이너가 정상적으로 실행되는 것을 확인했습니다. 각 서비스의 로그를 검사하여 오류 없이 시작되었음을 검증했습니다.\n</info added on 2025-06-27T10:06:27.673Z>",
            "status": "done",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 3,
        "title": "Configure MQTT Broker with Persistence",
        "description": "Set up and configure the Mosquitto MQTT broker with persistence and QoS settings to ensure reliable message delivery from the ESP32 device.",
        "details": "1. Create Mosquitto configuration directory: `mkdir -p mosquitto/config mosquitto/data mosquitto/log`\n2. Create mosquitto.conf file in mosquitto/config/ with the following content:\n```\nlistener 1883\nallow_anonymous true\n\npersistence true\npersistence_location /mosquitto/data/\nlog_dest file /mosquitto/log/mosquitto.log\n\n# QoS settings\nmax_queued_messages 1000\nmax_inflight_messages 20\n\n# Persistence settings\nautosave_interval 60\nqueue_qos0_messages true\n```\n3. Set proper permissions: `chmod -R 755 mosquitto`\n4. Configure the broker to handle QoS 1 or 2 messages to ensure delivery\n5. Set up persistent sessions to handle client reconnections\n6. Configure appropriate logging for troubleshooting\n7. Test the MQTT broker with a simple publish/subscribe client",
        "testStrategy": "1. Use MQTT client tools (e.g., mosquitto_pub/mosquitto_sub) to test publishing and subscribing\n2. Verify persistence by restarting the broker and checking if messages are retained\n3. Test QoS levels by simulating network interruptions\n4. Verify broker logs are being written correctly\n5. Test with sample payload matching the expected JSON format\n6. Benchmark message throughput to ensure it can handle messages every 5 seconds",
        "priority": "high",
        "dependencies": [
          2
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "Set Up MySQL Database with Schema",
        "description": "Create the MySQL database schema for storing power measurement data with indefinite retention, focusing on the power_readings table structure. Ensure that the schema explicitly documents the measurement units for each column: temperature (Celsius), humidity (percentage), brightness (numeric value), and electric (mA).",
        "status": "done",
        "dependencies": [
          2
        ],
        "priority": "high",
        "details": "1. Create the init.sql file in the mysql directory with the following schema:\n\n```sql\nCREATE DATABASE IF NOT EXISTS power_measurement;\nUSE power_measurement;\n\nCREATE TABLE IF NOT EXISTS power_readings (\n    id INT AUTO_INCREMENT PRIMARY KEY,\n    timestamp DATETIME NOT NULL,\n    device_code INT NOT NULL,\n    temperature FLOAT COMMENT 'Celsius',\n    humidity FLOAT COMMENT 'Percentage',\n    brightness INT COMMENT 'Numeric value',\n    electric FLOAT COMMENT 'mA',\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n    INDEX idx_timestamp (timestamp),\n    INDEX idx_device_code (device_code)\n);\n\n-- Create user with appropriate permissions\nCREATE USER IF NOT EXISTS 'power_user'@'%' IDENTIFIED BY '${MYSQL_PASSWORD}';\nGRANT ALL PRIVILEGES ON power_measurement.* TO 'power_user'@'%';\nFLUSH PRIVILEGES;\n```\n\n2. Configure MySQL for data durability:\n   - Set innodb_flush_log_at_trx_commit=1 for ACID compliance\n   - Configure appropriate buffer pool size based on Raspberry Pi memory\n   - Set up binary logging for potential point-in-time recovery\n\n3. Create a backup strategy for the database to ensure data is never lost",
        "testStrategy": "1. Verify database creation by connecting with a MySQL client\n2. Test table creation with the init.sql script\n3. Insert sample data matching the expected format, ensuring temperature is in Celsius, humidity in percentage, brightness as a numeric value, and electric in mA\n4. Query the data to ensure it's stored correctly and units are respected\n5. Verify indexes are created and working as expected\n6. Test database persistence by restarting the container\n7. Benchmark database performance with simulated load (5-second interval inserts)",
        "subtasks": []
      },
      {
        "id": 5,
        "title": "Develop Flask Backend Application",
        "description": "Create the Flask application that subscribes to MQTT messages, processes the JSON data, and stores it in the MySQL database while providing API endpoints for the frontend.",
        "details": "1. Create the Flask application directory structure:\n```\nflask_app/\n├── Dockerfile\n├── requirements.txt\n├── app.py\n└── modules/\n    ├── __init__.py\n    ├── mqtt_client.py\n    ├── database.py\n    └── api.py\n```\n\n2. Create requirements.txt:\n```\nflask==2.0.1\nflask-cors==3.0.10\npaho-mqtt==1.5.1\nmysql-connector-python==8.0.26\npython-dotenv==0.19.0\nrequests==2.26.0\n```\n\n3. Create Dockerfile:\n```dockerfile\nFROM python:3.9-slim\nWORKDIR /app\nCOPY requirements.txt .\nRUN pip install --no-cache-dir -r requirements.txt\nCOPY . .\nEXPOSE 5000\nCMD [\"python\", \"app.py\"]\n```\n\n4. Implement the MQTT client module (mqtt_client.py) to:\n   - Connect to the MQTT broker with QoS 1 or 2\n   - Subscribe to the power measurement topic\n   - Handle message reception and parsing\n   - Implement error handling and reconnection logic\n\n5. Implement the database module (database.py) to:\n   - Connect to MySQL\n   - Create functions to insert data\n   - Implement query functions for retrieving data\n\n6. Implement API endpoints in api.py:\n   - GET /api/power_data - retrieve power data with filtering options\n   - GET /api/summary - get daily/weekly summaries\n   - POST /api/generate_esg_report - trigger ESG report generation\n\n7. Implement the main app.py to tie everything together:\n```python\nfrom flask import Flask, jsonify, request\nfrom flask_cors import CORS\nfrom modules.mqtt_client import MQTTClient\nfrom modules.database import Database\nfrom modules.api import setup_routes\nimport os\nimport json\n\napp = Flask(__name__)\nCORS(app)\n\n# Initialize database connection\ndb = Database(\n    host=os.environ.get('MYSQL_HOST', 'mysql'),\n    user=os.environ.get('MYSQL_USER', 'power_user'),\n    password=os.environ.get('MYSQL_PASSWORD', 'password'),\n    database=os.environ.get('MYSQL_DATABASE', 'power_measurement')\n)\n\n# Setup API routes\nsetup_routes(app, db)\n\n# Initialize MQTT client\ndef on_message(client, userdata, message):\n    try:\n        payload = json.loads(message.payload.decode())\n        # Extract data from payload\n        device_code = payload.get('deviceCode')\n        timestamp = payload.get('timestamp')\n        temp = payload.get('temp')\n        humidity = payload.get('humidity')\n        brightness = payload.get('brightness')\n        electric = payload.get('electric')\n        \n        # Insert into database\n        db.insert_reading(device_code, timestamp, temp, humidity, brightness, electric)\n    except Exception as e:\n        print(f\"Error processing message: {e}\")\n\nmqtt_client = MQTTClient(\n    broker=os.environ.get('MQTT_BROKER', 'mosquitto'),\n    port=1883,\n    on_message=on_message\n)\n\nif __name__ == '__main__':\n    # Start MQTT client in background thread\n    mqtt_client.connect()\n    # Start Flask app\n    app.run(host='0.0.0.0', port=5000)\n```",
        "testStrategy": "1. Unit test each module (MQTT client, database, API) independently\n2. Test MQTT subscription with sample messages\n3. Verify database insertion with various data formats\n4. Test API endpoints with curl or Postman\n5. Verify error handling for malformed messages\n6. Test reconnection logic for MQTT and database\n7. Load test with simulated high-frequency messages\n8. Verify data integrity by comparing input and stored data",
        "priority": "high",
        "dependencies": [
          3,
          4
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Project Scaffolding",
            "description": "Set up the initial backend project structure using a scaffolding tool or manual folder organization to ensure clear separation of concerns and maintainability.",
            "dependencies": [],
            "details": "Create directories for source code, configuration, tests, and documentation. Initialize version control and basic project files.\n<info added on 2025-06-27T10:40:51.067Z>\nCreated the initial directory structure and empty files for the Flask application as follows:\n- `flask_app/modules`\n- `flask_app/requirements.txt`\n- `flask_app/app.py`\n- `flask_app/modules/__init__.py`\n- `flask_app/modules/mqtt_client.py`\n- `flask_app/modules/database.py`\n- `flask_app/modules/api.py`\n</info added on 2025-06-27T10:40:51.067Z>",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Requirements and Dockerfile Setup",
            "description": "Define project dependencies and create a Dockerfile for containerization to ensure consistent development and deployment environments.",
            "dependencies": [
              1
            ],
            "details": "List all required libraries in a requirements file (e.g., requirements.txt or package.json) and write a Dockerfile that installs dependencies and sets up the runtime environment.\n<info added on 2025-06-27T10:47:08.231Z>\nI've populated `flask_app/requirements.txt` with all necessary packages for our Flask backend application. \n\nCreated a `flask_app/Dockerfile` that leverages `uv` for faster Python dependency installation. The Dockerfile sets up the runtime environment and installs all dependencies from requirements.txt.\n\nDuring the Docker build process, I encountered and resolved several issues:\n- Fixed file path references in the Dockerfile\n- Added the `--system` flag to the `uv` command to ensure proper installation\n- Troubleshooted permission issues with the installation process\n\nPerformance testing confirms that using `uv` significantly improves build time compared to traditional pip installation methods, making it an excellent choice for our containerized environment.\n</info added on 2025-06-27T10:47:08.231Z>",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "MQTT Client Implementation",
            "description": "Develop and configure an MQTT client module to handle real-time messaging with external systems.",
            "dependencies": [
              2
            ],
            "details": "Choose an appropriate MQTT client library, implement connection logic, and set up message subscription and publishing handlers.\n<info added on 2025-06-27T11:02:34.041Z>\nImplemented the `MQTTClient` class in `flask_app/modules/mqtt_client.py` with the following features:\n- Connection management to MQTT broker\n- Topic subscription using environment variables\n- Background thread for message processing with callback function\n- Basic error handling for connection failures\n- Methods for publishing messages to topics\n\nThe implementation follows a class-based approach for better encapsulation and reusability across the application.\n</info added on 2025-06-27T11:02:34.041Z>",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Database Integration",
            "description": "Integrate a database system and implement data models and connection logic for persistent storage.",
            "dependencies": [
              2
            ],
            "details": "Select a database (e.g., PostgreSQL, MongoDB), configure connection settings, and define schema/models as needed.\n<info added on 2025-06-27T11:10:46.841Z>\nImplemented the `Database` class in `flask_app/modules/database.py` which uses a connection pool for efficient MySQL connections. The class provides methods for inserting and querying power reading data. Configuration is pulled from environment variables for improved security and flexibility. MySQL was selected as the database solution for this project.\n</info added on 2025-06-27T11:10:46.841Z>",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "API Endpoint Development",
            "description": "Design and implement RESTful API endpoints for client interaction and data manipulation.",
            "dependencies": [
              3,
              4
            ],
            "details": "Define API routes, request/response formats, and implement handlers for CRUD operations and MQTT-triggered actions.\n<info added on 2025-06-27T11:17:34.035Z>\n- Implemented API endpoints in `api.py` using a Flask Blueprint.\n- Created corresponding tests in `test_api.py` following TDD principles.\n- Resolved a `Werkzeug` dependency conflict by pinning the version to 2.0.3.\n- Fixed a JSON serialization `TypeError` by updating the serializer function to handle basic types.\n- All tests for the API module are now passing.\n</info added on 2025-06-27T11:17:34.035Z>",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Main Application Orchestration",
            "description": "Develop the main application entry point to orchestrate the MQTT client, database, and API server components.",
            "dependencies": [
              3,
              4,
              5
            ],
            "details": "Ensure all modules are initialized in the correct order and manage their lifecycle within the main application process.\n<info added on 2025-06-27T14:38:12.262Z>\n- Implemented the main application orchestration in `app.py`.\n- Integrated the Database, MQTTClient, and API modules.\n- Created a specific `on_message_callback` to process MQTT data and store it in the database.\n- Wrote unit tests for the callback function in `test_app.py`, covering success, failure, and edge cases.\n- Resolved a Docker build cache issue by using the `--no-cache` flag.\n- All 8 tests across the suite are now passing.\n</info added on 2025-06-27T14:38:12.262Z>",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 7,
            "title": "Unit Testing Setup",
            "description": "Set up a unit testing framework and write tests for individual modules to ensure code correctness.",
            "dependencies": [
              3,
              4,
              5,
              6
            ],
            "details": "Choose a testing framework (e.g., pytest, Jest), write tests for MQTT, database, and API logic, and configure test runners.\n<info added on 2025-06-27T14:41:14.303Z>\nTesting implementation was completed using pytest as the testing framework with pytest-mock for mocking functionality. Unit tests were developed alongside each module following Test-Driven Development (TDD) principles:\n- Database module tests (part of subtask 5.4)\n- API logic tests (part of subtask 5.5)\n- Main application tests (part of subtask 5.6)\n\nAll testing dependencies are properly configured in requirements.txt and have been verified to be working correctly. No separate testing implementation was needed as tests were integrated into the development of each component.\n</info added on 2025-06-27T14:41:14.303Z>",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 8,
            "title": "Error Handling Implementation",
            "description": "Implement robust error handling across all modules to ensure graceful failure and informative error reporting.",
            "dependencies": [
              5,
              6
            ],
            "details": "Add try/catch blocks, custom error classes, and centralized error logging for MQTT, database, and API operations.\n<info added on 2025-06-27T14:43:27.477Z>\n- Replaced all `print` statements with the standard Python `logging` module across `app.py`, `database.py`, and `mqtt_client.py`.\n- Configured a centralized logger in `app.py` with a consistent format.\n- Updated `test_app.py` to use the `caplog` fixture for testing logging output.\n- All tests passed, confirming the new error handling and logging system works as expected.\n</info added on 2025-06-27T14:43:27.477Z>",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 9,
            "title": "Integration Testing",
            "description": "Develop integration tests to verify that all components (MQTT, database, API) work together as expected.",
            "dependencies": [
              7,
              8
            ],
            "details": "Write tests that simulate real-world workflows and edge cases, ensuring end-to-end system reliability.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 10,
            "title": "Documentation and Final Review",
            "description": "Document the backend architecture, setup instructions, and API usage. Conduct a final code review and refactor as needed.",
            "dependencies": [],
            "details": "Prepare README, API docs, and developer guides. Review code for maintainability, security, and performance.",
            "status": "done",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 6,
        "title": "Develop Vue.js Frontend Application",
        "description": "Create the Vue.js frontend application that displays power consumption and environmental data through an intuitive dashboard with visualizations for all sensor values.",
        "details": "1. Set up Vue.js project structure:\n```\nvue_app/\n├── Dockerfile\n├── nginx.conf\n├── package.json\n├── public/\n└── src/\n    ├── assets/\n    ├── components/\n    │   ├── Dashboard.vue\n    │   ├── PowerChart.vue\n    │   ├── EnvironmentalData.vue\n    │   ├── ESGReport.vue\n    │   └── TimeRangeSelector.vue\n    ├── views/\n    │   ├── Home.vue\n    │   └── Reports.vue\n    ├── App.vue\n    ├── main.js\n    └── router.js\n```\n\n2. Create Dockerfile:\n```dockerfile\n# Build stage\nFROM node:14 as build-stage\nWORKDIR /app\nCOPY package*.json ./\nRUN npm install\nCOPY . .\nRUN npm run build\n\n# Production stage\nFROM nginx:stable-alpine as production-stage\nCOPY --from=build-stage /app/dist /usr/share/nginx/html\nCOPY nginx.conf /etc/nginx/conf.d/default.conf\nEXPOSE 80\nCMD [\"nginx\", \"-g\", \"daemon off;\"]\n```\n\n3. Create nginx.conf:\n```\nserver {\n    listen 80;\n    server_name localhost;\n\n    location / {\n        root /usr/share/nginx/html;\n        index index.html;\n        try_files $uri $uri/ /index.html;\n    }\n\n    location /api/ {\n        proxy_pass http://flask_app:5000;\n        proxy_set_header Host $host;\n        proxy_set_header X-Real-IP $remote_addr;\n    }\n}\n```\n\n4. Set up package.json with required dependencies:\n```json\n{\n  \"name\": \"power-measurement-dashboard\",\n  \"version\": \"0.1.0\",\n  \"private\": true,\n  \"scripts\": {\n    \"serve\": \"vue-cli-service serve\",\n    \"build\": \"vue-cli-service build\",\n    \"lint\": \"vue-cli-service lint\"\n  },\n  \"dependencies\": {\n    \"axios\": \"^0.21.1\",\n    \"chart.js\": \"^3.5.0\",\n    \"core-js\": \"^3.6.5\",\n    \"moment\": \"^2.29.1\",\n    \"vue\": \"^3.0.0\",\n    \"vue-chart-3\": \"^0.5.8\",\n    \"vue-router\": \"^4.0.0-0\"\n  },\n  \"devDependencies\": {\n    \"@vue/cli-plugin-babel\": \"~4.5.0\",\n    \"@vue/cli-plugin-eslint\": \"~4.5.0\",\n    \"@vue/cli-plugin-router\": \"~4.5.0\",\n    \"@vue/cli-service\": \"~4.5.0\",\n    \"@vue/compiler-sfc\": \"^3.0.0\",\n    \"babel-eslint\": \"^10.1.0\",\n    \"eslint\": \"^6.7.2\",\n    \"eslint-plugin-vue\": \"^7.0.0\"\n  }\n}\n```\n\n5. Implement key components:\n   - Dashboard.vue: Main dashboard with current power consumption display\n   - PowerChart.vue: Line chart for electric power trends\n   - EnvironmentalData.vue: Display for temperature, humidity, and brightness\n   - TimeRangeSelector.vue: Component for selecting time ranges\n   - ESGReport.vue: Component for displaying ESG reports\n\n6. Implement API service for data fetching:\n```javascript\n// src/services/api.js\nimport axios from 'axios';\n\nconst apiClient = axios.create({\n  baseURL: '/api',\n  timeout: 10000,\n  headers: {\n    'Content-Type': 'application/json'\n  }\n});\n\nexport default {\n  getPowerData(params) {\n    return apiClient.get('/power_data', { params });\n  },\n  getSummary(timeRange) {\n    return apiClient.get('/summary', { params: { timeRange } });\n  },\n  generateESGReport() {\n    return apiClient.post('/generate_esg_report');\n  }\n};\n```",
        "testStrategy": "1. Unit test Vue components with Jest\n2. Test API integration with mock data\n3. Verify responsive design on different screen sizes\n4. Test chart rendering with various data sets\n5. Verify time range selection functionality\n6. Test ESG report display with sample data\n7. Perform end-to-end testing with Cypress\n8. Verify proper error handling for API failures",
        "priority": "medium",
        "dependencies": [
          5
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Project Setup and Environment Configuration",
            "description": "Initialize the project repository, set up the development environment, and configure essential tools and dependencies.",
            "dependencies": [],
            "details": "Create a new repository, initialize the project with appropriate framework (React/Vue/Angular), set up package.json, install core dependencies, configure linting and formatting tools, and establish the project structure with appropriate folders for components, services, and assets.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Docker and Nginx Configuration",
            "description": "Set up Docker containerization and Nginx for serving the application.",
            "dependencies": [
              1
            ],
            "details": "Create Dockerfile for the frontend application, configure Nginx as a reverse proxy, set up Docker Compose for local development, and ensure proper configuration for production deployment with appropriate caching and compression settings.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Dashboard Layout and Navigation Implementation",
            "description": "Develop the main dashboard layout and navigation components.",
            "dependencies": [
              1
            ],
            "details": "Create responsive layout components, implement navigation bar/sidebar, design dashboard grid system, implement routing between different sections, and ensure consistent header/footer elements across the application.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Data Visualization Charts Development",
            "description": "Implement various chart components for data visualization.",
            "dependencies": [
              3
            ],
            "details": "Select and integrate appropriate charting library (D3.js, Chart.js, etc.), develop reusable chart components (line charts, bar charts, pie charts), implement data transformation utilities, and ensure charts are interactive with tooltips and responsive to different screen sizes.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "ESG Report Component Development",
            "description": "Create components for displaying and interacting with ESG (Environmental, Social, and Governance) reports.",
            "dependencies": [
              3
            ],
            "details": "Design and implement ESG report templates, create data visualization specific to ESG metrics, develop filtering and sorting capabilities for ESG data, and implement export functionality for reports.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "API Integration and Data Management",
            "description": "Implement services for API integration and data management throughout the application.",
            "dependencies": [
              1
            ],
            "details": "Create API service layer, implement authentication and authorization, develop data fetching and caching strategies, handle error states and loading indicators, and ensure proper data transformation between API and UI components.\n<info added on 2025-08-05T04:03:48.011Z>\nAPI Integration and Data Management improvements completed:\n\nKey features implemented:\n\n1. Enhanced API service layer (vue_app/src/services/api.js):\n   - Data caching system with 30-second TTL\n   - Loading state management\n   - Systematic error handling (server errors, network errors, other errors)\n   - Data validation\n   - Optimized functions for environmental and power data\n   - Cache management functions (clearCache, clearCacheByPattern)\n\n2. Improved Socket.IO service (vue_app/src/services/socket.js):\n   - Real-time connection status tracking (connected, connecting, disconnected, error)\n   - Automatic reconnection logic (maximum 5 attempts)\n   - Error handling and logging\n   - Safe event listener management (safeOn)\n   - Data validation function (validateReadingData)\n   - Manual connection/disconnection and reconnection capabilities\n\n3. Extended backend API (flask_app/modules/):\n   - database.py: Added methods for summary and trend data retrieval\n   - api.py: Implemented /summary and /trend endpoints\n   - Time range support (1h, 6h, 24h, 7d, 30d)\n   - Statistical data (average, minimum, maximum, total)\n   - Hourly trend data\n\n4. Enhanced EnvironmentalData component:\n   - Real-time connection status display\n   - Error messages and retry functionality\n   - Loading state visualization\n   - Responsive design\n   - Improved UX/UI\n\nNext steps: Apply similar improvements to CurrentPowerDisplay and PowerChart components.\n</info added on 2025-08-05T04:03:48.011Z>",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 7,
            "title": "Styling and UI Refinement",
            "description": "Apply consistent styling across the application and refine the user interface.",
            "dependencies": [
              3,
              4,
              5
            ],
            "details": "Implement design system or UI component library, create custom CSS/SCSS styles, ensure consistent theming, implement dark/light mode if required, and optimize visual elements for different devices and screen sizes.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 8,
            "title": "Testing and Responsive Design Validation",
            "description": "Implement comprehensive testing and validate responsive design across devices.",
            "dependencies": [
              4,
              5,
              6,
              7
            ],
            "details": "Write unit tests for components and services, implement integration tests for key user flows, perform cross-browser testing, validate responsive design on various devices and screen sizes, and conduct performance testing for data-heavy visualizations.\n<info added on 2025-08-05T04:12:00.915Z>\n✅ **Unit Testing 강화**:\n- EnvironmentalData 컴포넌트: 12개 테스트 케이스\n  - 연결 상태 표시 테스트\n  - 에러 핸들링 및 재시도 기능\n  - 로딩 상태 관리\n  - Socket 이벤트 처리\n  - 데이터 검증\n  - 반응형 디자인\n- API 서비스: 15개 테스트 케이스\n  - 캐싱 메커니즘\n  - 에러 핸들링 (서버, 네트워크, 데이터 형식)\n  - 로딩 상태 추적\n  - 데이터 변환 및 검증\n\n✅ **E2E Testing (Cypress)**:\n- 대시보드 전체 플로우: 12개 테스트 시나리오\n- API 에러 처리 및 재시도 로직\n- 실시간 데이터 업데이트\n- 반응형 디자인 (모바일, 태블릿, 데스크톱)\n- 네비게이션 및 라우팅\n- 로딩 상태 및 데이터 검증\n\n✅ **성능 테스트**:\n- 컴포넌트 렌더링 시간 (<100ms)\n- 대용량 데이터셋 처리 (<500ms for 1000 records)\n- 메모리 누수 방지 (<10MB increase)\n- API 캐싱 최적화\n\n✅ **접근성 테스트**:\n- ARIA 라벨 및 역할\n- 키보드 네비게이션 지원\n- 색상 대비 확인\n- 시맨틱 HTML 구조\n- 스크린 리더 지원\n- 포커스 관리\n- 에러 메시지 접근성\n\n✅ **반응형 디자인 검증**:\n- 모바일 (375px): 세로 스택 레이아웃\n- 태블릿 (768px): 적응형 그리드\n- 데스크톱 (1280px+): 전체 기능 레이아웃\n- CSS Grid 및 Flexbox 활용\n- 미디어 쿼리 구현\n\n**테스트 도구**: Vitest (unit), Cypress (E2E), Testing Library (component testing)\n</info added on 2025-08-05T04:12:00.915Z>\n<info added on 2025-08-05T04:46:28.328Z>\n✅ **테스트 작업 완료!** (2025-01-20)\n\n**최종 테스트 결과:**\n- **40개 테스트 모두 통과** (100% 성공률)\n- **7개 테스트 파일** 모두 성공\n- 실행 시간: 3.94초\n\n**해결한 주요 문제들:**\n1. **Vitest Mocking 구조 개선**: hoisting 문제 해결로 axios, socket.io-client 모킹 정상화\n2. **EnvironmentalData 컴포넌트**: hasError/socketHasError import 문제 해결\n3. **API 서비스 테스트**: 에러 처리 형태 수정으로 모든 API 테스트 통과  \n4. **의존성 설치**: socket.io-client 등 누락된 패키지 설치 완료\n5. **ESGReport 컴포넌트**: default/named import mock 구조 개선\n\n**테스트 커버리지:**\n- **API 서비스**: 캐싱, 로딩, 에러 처리 (11개 테스트)\n- **EnvironmentalData**: UI, 상태 관리, 실시간 연결 (12개 테스트)  \n- **성능/접근성**: 렌더링 성능, ARIA, 키보드 지원 (12개 테스트)\n- **기타 컴포넌트**: HelloWorld, ESGReport, PowerChart, NavBar (5개 테스트)\n\n모든 테스트가 안정적으로 실행되며, 향후 개발 시 코드 품질을 보장할 수 있는 견고한 테스트 기반이 구축되었습니다!\n</info added on 2025-08-05T04:46:28.328Z>",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 9,
            "title": "Real-time data streaming with Socket.IO",
            "description": "Implement WebSocket on Flask & Vue for live dashboard",
            "details": "<info added on 2025-08-05T04:06:23.847Z>\n# Real-time Data Streaming with Socket.IO Implementation\n\n## Flask Backend Socket.IO Enhancements\n- Client connection/disconnection tracking (connected_clients set)\n- Connection status event handlers (connect, disconnect)\n- Real-time ping/pong health check mechanism\n- Latest data request functionality (get_latest_data)\n- Room-based client management (join_room, leave_room)\n- Enhanced error handling and logging\n- Server status information transmission (MQTT connection status, DB status, etc.)\n\n## Vue.js Frontend Socket.IO Extensions\n- Server status tracking (serverStatus reactive)\n- Latest data request functionality from server (requestLatestData)\n- Connection quality testing (testConnectionQuality with latency measurement)\n- Room management functionality (joinRoom, leaveRoom)\n- Ping/pong testing (sendPing)\n- Enhanced server error handling\n- Extended real-time event listeners\n\n## Maintained Functionality\n- Real-time broadcasting of MQTT messages to all connected clients\n- Automatic reconnection logic\n- Data validation and error handling\n\n## Result\nA fully functional real-time data streaming system where ESP32 sensor data is transmitted in real-time via MQTT → Flask → Socket.IO → Vue.js pathway.\n</info added on 2025-08-05T04:06:23.847Z>",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 6
          }
        ]
      },
      {
        "id": 7,
        "title": "Implement AI/LLM Module for ESG Report Generation",
        "description": "Develop the AI/LLM module that interfaces with the Claude API to generate ESG reports focused on environmental aspects, including carbon emission calculations based on power consumption data.",
        "details": "1. Create the AI/LLM module directory structure:\n```\nai_llm_module/\n├── Dockerfile\n├── requirements.txt\n├── app.py\n└── modules/\n    ├── __init__.py\n    ├── database.py\n    ├── claude_api.py\n    └── carbon_calculator.py\n```\n\n2. Create requirements.txt:\n```\nmysql-connector-python==8.0.26\npython-dotenv==0.19.0\nrequests==2.26.0\nflask==2.0.1\npandas==1.3.3\n```\n\n3. Create Dockerfile:\n```dockerfile\nFROM python:3.9-slim\nWORKDIR /app\nCOPY requirements.txt .\nRUN pip install --no-cache-dir -r requirements.txt\nCOPY . .\nEXPOSE 5000\nCMD [\"python\", \"app.py\"]\n```\n\n4. Implement the database module (database.py) to query recent 3 months of data:\n```python\nimport mysql.connector\nimport pandas as pd\nfrom datetime import datetime, timedelta\n\nclass Database:\n    def __init__(self, host, user, password, database):\n        self.config = {\n            'host': host,\n            'user': user,\n            'password': password,\n            'database': database\n        }\n    \n    def connect(self):\n        return mysql.connector.connect(**self.config)\n    \n    def get_recent_data(self, months=3):\n        conn = self.connect()\n        cursor = conn.cursor(dictionary=True)\n        \n        # Calculate date 3 months ago\n        three_months_ago = (datetime.now() - timedelta(days=90)).strftime('%Y-%m-%d')\n        \n        query = \"\"\"\n        SELECT * FROM power_readings \n        WHERE timestamp >= %s \n        ORDER BY timestamp\n        \"\"\"\n        \n        cursor.execute(query, (three_months_ago,))\n        result = cursor.fetchall()\n        \n        cursor.close()\n        conn.close()\n        \n        return pd.DataFrame(result)\n    \n    def get_daily_summaries(self, months=3):\n        conn = self.connect()\n        cursor = conn.cursor(dictionary=True)\n        \n        three_months_ago = (datetime.now() - timedelta(days=90)).strftime('%Y-%m-%d')\n        \n        query = \"\"\"\n        SELECT \n            DATE(timestamp) as date,\n            AVG(temperature) as avg_temp,\n            AVG(humidity) as avg_humidity,\n            AVG(brightness) as avg_brightness,\n            AVG(electric) as avg_electric,\n            SUM(electric) as total_electric\n        FROM power_readings\n        WHERE timestamp >= %s\n        GROUP BY DATE(timestamp)\n        ORDER BY date\n        \"\"\"\n        \n        cursor.execute(query, (three_months_ago,))\n        result = cursor.fetchall()\n        \n        cursor.close()\n        conn.close()\n        \n        return pd.DataFrame(result)\n```\n\n5. Implement carbon calculator module (carbon_calculator.py):\n```python\ndef calculate_carbon_emissions(electric_data):\n    \"\"\"Calculate carbon emissions based on electricity consumption.\n    \n    Args:\n        electric_data: DataFrame with 'date' and 'total_electric' columns\n        \n    Returns:\n        DataFrame with date and carbon emissions in kgCO2\n    \"\"\"\n    # Carbon emission factor: 0.478 kgCO₂/kWh\n    EMISSION_FACTOR = 0.478\n    \n    # Copy the dataframe to avoid modifying the original\n    result = electric_data.copy()\n    \n    # Calculate carbon emissions\n    result['carbon_emissions'] = result['total_electric'] * EMISSION_FACTOR\n    \n    return result\n```\n\n6. Implement Claude API module (claude_api.py):\n```python\nimport requests\nimport json\nimport os\n\nclass ClaudeAPI:\n    def __init__(self, api_key):\n        self.api_key = api_key\n        self.api_url = \"https://api.anthropic.com/v1/messages\"\n    \n    def generate_esg_report(self, data, carbon_data):\n        \"\"\"Generate an ESG report using Claude API.\n        \n        Args:\n            data: DataFrame with daily summaries\n            carbon_data: DataFrame with carbon emissions\n            \n        Returns:\n            JSON structure with the ESG report\n        \"\"\"\n        # Prepare data for the prompt\n        data_json = data.to_json(orient='records', date_format='iso')\n        carbon_json = carbon_data.to_json(orient='records', date_format='iso')\n        \n        # Create prompt for Claude\n        prompt = f\"\"\"\n        You are an environmental analyst creating an ESG (Environmental, Social, Governance) report focused only on the Environmental aspects. \n        You have access to the following power consumption and environmental data from the past 3 months:\n        \n        Daily summaries: {data_json}\n        \n        Carbon emissions: {carbon_json}\n        \n        Please generate a comprehensive ESG report that includes:\n        \n        1. An executive summary of environmental performance\n        2. Analysis of power consumption trends and patterns\n        3. Correlation between environmental factors (temperature, humidity, brightness) and power consumption\n        4. Carbon emission analysis based on the provided data (using factor 0.478 kgCO₂/kWh)\n        5. Personalized recommendations for reducing power consumption and carbon footprint\n        6. The following tables with calculated values based on the provided data:\n           - Energy Usage table (monthly totals)\n           - Carbon Emissions table (monthly totals)\n        \n        Format the tables as structured data that can be easily displayed in an HTML table.\n        \"\"\"\n        \n        # Call Claude API\n        headers = {\n            \"x-api-key\": self.api_key,\n            \"content-type\": \"application/json\"\n        }\n        \n        payload = {\n            \"model\": \"claude-2\",\n            \"prompt\": prompt,\n            \"max_tokens_to_sample\": 4000,\n            \"temperature\": 0.5\n        }\n        \n        response = requests.post(self.api_url, headers=headers, json=payload)\n        \n        if response.status_code == 200:\n            result = response.json()\n            return self._parse_report(result['completion'])\n        else:\n            raise Exception(f\"API call failed: {response.text}\")\n    \n    def _parse_report(self, text):\n        \"\"\"Parse the report text into a structured format.\"\"\"\n        # This is a simplified parser - in a real implementation,\n        # you would need more robust parsing logic\n        sections = {\n            \"summary\": \"\",\n            \"analysis\": \"\",\n            \"recommendations\": \"\",\n            \"tables\": {}\n        }\n        \n        # Extract sections and tables from the text\n        # This would need to be implemented based on Claude's output format\n        \n        return sections\n```\n\n7. Implement the main app.py:\n```python\nfrom flask import Flask, jsonify, request\nfrom modules.database import Database\nfrom modules.claude_api import ClaudeAPI\nfrom modules.carbon_calculator import calculate_carbon_emissions\nimport os\n\napp = Flask(__name__)\n\n# Initialize database connection\ndb = Database(\n    host=os.environ.get('MYSQL_HOST', 'mysql'),\n    user=os.environ.get('MYSQL_USER', 'power_user'),\n    password=os.environ.get('MYSQL_PASSWORD', 'password'),\n    database=os.environ.get('MYSQL_DATABASE', 'power_measurement')\n)\n\n# Initialize Claude API client\nclaude_api = ClaudeAPI(os.environ.get('ANTHROPIC_API_KEY'))\n\n@app.route('/generate_report', methods=['POST'])\ndef generate_report():\n    try:\n        # Get recent data\n        daily_data = db.get_daily_summaries()\n        \n        # Calculate carbon emissions\n        carbon_data = calculate_carbon_emissions(daily_data)\n        \n        # Generate ESG report\n        report = claude_api.generate_esg_report(daily_data, carbon_data)\n        \n        return jsonify(report)\n    except Exception as e:\n        return jsonify({'error': str(e)}), 500\n\nif __name__ == '__main__':\n    app.run(host='0.0.0.0', port=5000)\n```",
        "testStrategy": "1. Unit test each module (database, carbon calculator, Claude API)\n2. Test with mock data to verify carbon emission calculations\n3. Test API integration with sample responses\n4. Verify report generation with different data sets\n5. Test error handling for API failures\n6. Verify the structure of generated reports\n7. Test with edge cases (missing data, extreme values)\n8. Benchmark performance with large datasets",
        "priority": "medium",
        "dependencies": [
          4,
          5
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Project Setup and Directory Structure",
            "description": "Initialize the AI/LLM module project, create the required directory structure, and set up version control.",
            "dependencies": [],
            "details": "Create the ai_llm_module/ directory with subfolders and files as specified (Dockerfile, requirements.txt, app.py, modules/ with __init__.py, database.py, claude_api.py, carbon_calculator.py). Initialize a git repository and add a README with high-level module goals.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Define Requirements and Dockerfile",
            "description": "Specify Python dependencies and create a Dockerfile for containerized deployment.",
            "dependencies": [
              "7.1"
            ],
            "details": "Write requirements.txt with all necessary packages (mysql-connector-python, python-dotenv, requests, flask, pandas). Create a Dockerfile that sets up a Python 3.9 environment, installs dependencies, and prepares the app for execution.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Implement Database Access Module",
            "description": "Develop the database.py module to handle connections and queries for power consumption and related data.",
            "dependencies": [
              "7.1",
              "7.2"
            ],
            "details": "Implement functions for connecting to the MySQL database, retrieving power consumption data, and supporting queries needed for carbon calculations and report generation.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Develop Carbon Calculation Logic",
            "description": "Create the carbon_calculator.py module to compute carbon emissions from power consumption data.",
            "dependencies": [
              "7.3"
            ],
            "details": "Implement functions to process power data, apply emission factors, and output carbon emission values suitable for ESG reporting.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Integrate Claude API and Report Parsing",
            "description": "Develop claude_api.py for Claude API integration and implement report parsing logic for ESG report generation.",
            "dependencies": [
              "7.4"
            ],
            "details": "Implement functions to send prompts and data to the Claude API, handle responses, and parse/generate structured ESG reports based on AI output and carbon calculations.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Implement API Endpoint and Module/Unit Testing",
            "description": "Expose the ESG report generation functionality via a Flask API endpoint and write unit tests for all modules.",
            "dependencies": [
              "7.5"
            ],
            "details": "Add a Flask route in app.py for ESG report requests, integrate all modules, and write unit tests for database, carbon calculator, Claude API integration, and the API endpoint using mock data and responses.",
            "status": "done",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 8,
        "title": "Integrate ESG Report Display in Frontend",
        "description": "Enhance the Vue.js frontend to display the AI-generated ESG reports with tables for energy usage, carbon emissions, and other environmental metrics. Support multiple device scenarios with device-specific, group-based, and consolidated ESG reports.",
        "status": "pending",
        "dependencies": [
          6,
          7
        ],
        "priority": "medium",
        "details": "1. Create an ESGReport.vue component with device selection:\n```vue\n<template>\n  <div class=\"esg-report\">\n    <div class=\"report-controls\">\n      <div class=\"report-type-selector\">\n        <label for=\"reportType\">Report Type:</label>\n        <select id=\"reportType\" v-model=\"reportType\" @change=\"resetReport\">\n          <option value=\"device\">Single Device</option>\n          <option value=\"group\">Device Group</option>\n          <option value=\"consolidated\">Consolidated</option>\n        </select>\n      </div>\n      \n      <div v-if=\"reportType === 'device'\" class=\"device-selector\">\n        <label for=\"deviceId\">Select Device:</label>\n        <select id=\"deviceId\" v-model=\"deviceId\" @change=\"resetReport\">\n          <option v-for=\"device in devices\" :key=\"device.id\" :value=\"device.id\">\n            {{ device.name }} (ID: {{ device.id }})\n          </option>\n        </select>\n      </div>\n      \n      <div v-if=\"reportType === 'group'\" class=\"group-selector\">\n        <label for=\"groupId\">Select Group:</label>\n        <select id=\"groupId\" v-model=\"groupId\" @change=\"resetReport\">\n          <option v-for=\"group in groups\" :key=\"group.id\" :value=\"group.id\">\n            {{ group.name }}\n          </option>\n        </select>\n      </div>\n      \n      <button @click=\"generateReport\" :disabled=\"loading\">\n        {{ report ? 'Regenerate Report' : 'Generate Report' }}\n      </button>\n    </div>\n    \n    <div v-if=\"loading\" class=\"loading\">\n      <p>Generating ESG report...</p>\n      <div class=\"spinner\"></div>\n    </div>\n    \n    <div v-else-if=\"error\" class=\"error\">\n      <p>Error generating report: {{ error }}</p>\n      <button @click=\"generateReport\">Try Again</button>\n    </div>\n    \n    <div v-else-if=\"report\" class=\"report-content\">\n      <h2>Environmental ESG Report</h2>\n      <div class=\"report-meta\">\n        <p v-if=\"reportType === 'device'\">Device: {{ selectedDeviceName }}</p>\n        <p v-else-if=\"reportType === 'group'\">Group: {{ selectedGroupName }}</p>\n        <p v-else>Consolidated Report (All Devices)</p>\n        <p>Generated: {{ formatDate(report.generatedAt) }}</p>\n      </div>\n      \n      <div class=\"summary\">\n        <h3>Executive Summary</h3>\n        <p>{{ report.summary }}</p>\n      </div>\n      \n      <div class=\"analysis\">\n        <h3>Analysis</h3>\n        <p>{{ report.analysis }}</p>\n      </div>\n      \n      <div class=\"tables\">\n        <h3>Energy Usage</h3>\n        <table v-if=\"report.tables.energyUsage\">\n          <thead>\n            <tr>\n              <th>Category</th>\n              <th>Unit</th>\n              <th v-for=\"period in report.tables.energyUsage.periods\" :key=\"period\">\n                {{ period }}\n              </th>\n            </tr>\n          </thead>\n          <tbody>\n            <tr v-for=\"row in report.tables.energyUsage.rows\" :key=\"row.category\">\n              <td>{{ row.category }}</td>\n              <td>{{ row.unit }}</td>\n              <td v-for=\"(value, period) in row.values\" :key=\"period\">\n                {{ value }}\n              </td>\n            </tr>\n          </tbody>\n        </table>\n        \n        <h3>Carbon Emissions</h3>\n        <table v-if=\"report.tables.carbonEmissions\">\n          <thead>\n            <tr>\n              <th>Category</th>\n              <th>Unit</th>\n              <th v-for=\"period in report.tables.carbonEmissions.periods\" :key=\"period\">\n                {{ period }}\n              </th>\n            </tr>\n          </thead>\n          <tbody>\n            <tr v-for=\"row in report.tables.carbonEmissions.rows\" :key=\"row.category\">\n              <td>{{ row.category }}</td>\n              <td>{{ row.unit }}</td>\n              <td v-for=\"(value, period) in row.values\" :key=\"period\">\n                {{ value }}\n              </td>\n            </tr>\n          </tbody>\n        </table>\n        \n        <div v-if=\"reportType !== 'device'\" class=\"device-comparison\">\n          <h3>Device Comparison</h3>\n          <table class=\"comparison-table\">\n            <thead>\n              <tr>\n                <th>Device</th>\n                <th>Energy Efficiency</th>\n                <th>Carbon Footprint</th>\n                <th>Improvement Potential</th>\n              </tr>\n            </thead>\n            <tbody>\n              <tr v-for=\"device in report.deviceComparison\" :key=\"device.id\">\n                <td>{{ device.name }}</td>\n                <td :class=\"getEfficiencyClass(device.efficiency)\">{{ device.efficiency }}</td>\n                <td>{{ device.carbonFootprint }}</td>\n                <td>{{ device.improvementPotential }}%</td>\n              </tr>\n            </tbody>\n          </table>\n        </div>\n      </div>\n      \n      <div class=\"recommendations\">\n        <h3>Recommendations</h3>\n        <p>{{ report.recommendations }}</p>\n      </div>\n    </div>\n    \n    <div v-else class=\"no-report\">\n      <p>No ESG report available. Select options and generate a report.</p>\n    </div>\n  </div>\n</template>\n\n<script>\nimport api from '../services/api';\n\nexport default {\n  name: 'ESGReport',\n  data() {\n    return {\n      report: null,\n      loading: false,\n      error: null,\n      reportType: 'consolidated',\n      deviceId: null,\n      groupId: null,\n      devices: [],\n      groups: []\n    };\n  },\n  computed: {\n    selectedDeviceName() {\n      const device = this.devices.find(d => d.id === this.deviceId);\n      return device ? device.name : '';\n    },\n    selectedGroupName() {\n      const group = this.groups.find(g => g.id === this.groupId);\n      return group ? group.name : '';\n    }\n  },\n  async created() {\n    try {\n      const [devicesResponse, groupsResponse] = await Promise.all([\n        api.getDevices(),\n        api.getDeviceGroups()\n      ]);\n      this.devices = devicesResponse.data;\n      this.groups = groupsResponse.data;\n      \n      if (this.devices.length > 0) {\n        this.deviceId = this.devices[0].id;\n      }\n      \n      if (this.groups.length > 0) {\n        this.groupId = this.groups[0].id;\n      }\n    } catch (err) {\n      this.error = 'Failed to load devices and groups';\n    }\n  },\n  methods: {\n    resetReport() {\n      this.report = null;\n      this.error = null;\n    },\n    async generateReport() {\n      this.loading = true;\n      this.error = null;\n      \n      try {\n        let response;\n        \n        if (this.reportType === 'device') {\n          response = await api.generateDeviceESGReport(this.deviceId);\n        } else if (this.reportType === 'group') {\n          response = await api.generateGroupESGReport(this.groupId);\n        } else {\n          response = await api.generateConsolidatedESGReport();\n        }\n        \n        this.report = response.data;\n      } catch (err) {\n        this.error = err.message || 'Failed to generate report';\n      } finally {\n        this.loading = false;\n      }\n    },\n    formatDate(dateString) {\n      const date = new Date(dateString);\n      return date.toLocaleString();\n    },\n    getEfficiencyClass(efficiency) {\n      if (efficiency === 'High') return 'high-efficiency';\n      if (efficiency === 'Medium') return 'medium-efficiency';\n      return 'low-efficiency';\n    }\n  }\n};\n</script>\n\n<style scoped>\n.esg-report {\n  padding: 20px;\n}\n\n.report-controls {\n  display: flex;\n  flex-wrap: wrap;\n  gap: 15px;\n  margin-bottom: 20px;\n  padding: 15px;\n  background-color: #f5f5f5;\n  border-radius: 5px;\n}\n\n.report-type-selector,\n.device-selector,\n.group-selector {\n  display: flex;\n  align-items: center;\n  gap: 10px;\n}\n\nselect {\n  padding: 8px;\n  border-radius: 4px;\n  border: 1px solid #ddd;\n}\n\n.loading {\n  text-align: center;\n  padding: 40px;\n}\n\n.spinner {\n  border: 4px solid rgba(0, 0, 0, 0.1);\n  border-radius: 50%;\n  border-top: 4px solid #3498db;\n  width: 30px;\n  height: 30px;\n  animation: spin 1s linear infinite;\n  margin: 20px auto;\n}\n\n@keyframes spin {\n  0% { transform: rotate(0deg); }\n  100% { transform: rotate(360deg); }\n}\n\n.error {\n  color: red;\n  padding: 20px;\n  text-align: center;\n}\n\n.report-content {\n  max-width: 1000px;\n  margin: 0 auto;\n}\n\n.report-meta {\n  background-color: #f9f9f9;\n  padding: 10px;\n  border-radius: 5px;\n  margin-bottom: 20px;\n  font-size: 0.9em;\n}\n\ntable {\n  width: 100%;\n  border-collapse: collapse;\n  margin-bottom: 20px;\n}\n\ntable th, table td {\n  border: 1px solid #ddd;\n  padding: 8px;\n  text-align: left;\n}\n\ntable th {\n  background-color: #f2f2f2;\n}\n\n.comparison-table .high-efficiency {\n  color: green;\n  font-weight: bold;\n}\n\n.comparison-table .medium-efficiency {\n  color: orange;\n}\n\n.comparison-table .low-efficiency {\n  color: red;\n}\n\nbutton {\n  padding: 10px 15px;\n  background-color: #4CAF50;\n  color: white;\n  border: none;\n  cursor: pointer;\n  border-radius: 4px;\n}\n\nbutton:hover {\n  background-color: #45a049;\n}\n\nbutton:disabled {\n  background-color: #cccccc;\n  cursor: not-allowed;\n}\n</style>\n```\n\n2. Update the Reports.vue view to support multiple report types:\n```vue\n<template>\n  <div class=\"reports-view\">\n    <h1>Environmental Reports</h1>\n    <div class=\"reports-description\">\n      <p>Generate and view ESG (Environmental, Social, and Governance) reports for individual devices, device groups, or your entire system.</p>\n    </div>\n    <ESGReport />\n  </div>\n</template>\n\n<script>\nimport ESGReport from '../components/ESGReport.vue';\n\nexport default {\n  name: 'Reports',\n  components: {\n    ESGReport\n  }\n};\n</script>\n\n<style scoped>\n.reports-view {\n  padding: 20px;\n}\n\n.reports-description {\n  max-width: 800px;\n  margin: 0 auto 30px;\n  color: #666;\n  line-height: 1.5;\n}\n</style>\n```\n\n3. Update the router.js file to include the Reports view:\n```javascript\nimport { createRouter, createWebHistory } from 'vue-router';\nimport Home from './views/Home.vue';\nimport Reports from './views/Reports.vue';\n\nconst routes = [\n  {\n    path: '/',\n    name: 'Home',\n    component: Home\n  },\n  {\n    path: '/reports',\n    name: 'Reports',\n    component: Reports\n  }\n];\n\nconst router = createRouter({\n  history: createWebHistory(),\n  routes\n});\n\nexport default router;\n```\n\n4. Add navigation in App.vue:\n```vue\n<template>\n  <div id=\"app\">\n    <nav>\n      <router-link to=\"/\">Dashboard</router-link> |\n      <router-link to=\"/reports\">Reports</router-link>\n    </nav>\n    <router-view/>\n  </div>\n</template>\n\n<style>\n#app {\n  font-family: Avenir, Helvetica, Arial, sans-serif;\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n  color: #2c3e50;\n}\n\nnav {\n  padding: 30px;\n  text-align: center;\n}\n\nnav a {\n  font-weight: bold;\n  color: #2c3e50;\n  text-decoration: none;\n  margin: 0 10px;\n}\n\nnav a.router-link-exact-active {\n  color: #42b983;\n}\n</style>\n```\n\n5. Update the API service to handle multiple ESG report types:\n```javascript\n// Add to src/services/api.js\ngetDevices() {\n  return apiClient.get('/devices');\n},\ngetDeviceGroups() {\n  return apiClient.get('/device_groups');\n},\ngenerateDeviceESGReport(deviceId) {\n  return apiClient.post(`/generate_esg_report/device/${deviceId}`);\n},\ngenerateGroupESGReport(groupId) {\n  return apiClient.post(`/generate_esg_report/group/${groupId}`);\n},\ngenerateConsolidatedESGReport() {\n  return apiClient.post('/generate_esg_report/consolidated');\n},\ngetESGReport(reportId) {\n  return apiClient.get(`/esg_report/${reportId}`);\n}\n```\n\n6. Add CSS styles for the tables and report display:\n```css\n/* Add to a global CSS file or component styles */\n.table-container {\n  overflow-x: auto;\n  margin-bottom: 20px;\n}\n\n.esg-table {\n  width: 100%;\n  border-collapse: collapse;\n  font-size: 14px;\n}\n\n.esg-table th, .esg-table td {\n  border: 1px solid #ddd;\n  padding: 8px;\n  text-align: right;\n}\n\n.esg-table th:first-child, .esg-table td:first-child {\n  text-align: left;\n}\n\n.esg-table th {\n  background-color: #f2f2f2;\n  font-weight: bold;\n}\n\n.esg-table tr:nth-child(even) {\n  background-color: #f9f9f9;\n}\n\n/* Add styles for device comparison table */\n.device-comparison {\n  margin-top: 30px;\n}\n\n.comparison-table {\n  width: 100%;\n  border-collapse: collapse;\n  margin-top: 10px;\n}\n\n.comparison-table th, .comparison-table td {\n  border: 1px solid #ddd;\n  padding: 10px;\n  text-align: center;\n}\n\n.comparison-table th:first-child, .comparison-table td:first-child {\n  text-align: left;\n}\n```",
        "testStrategy": "1. Test the ESG report component with mock data for single device, group, and consolidated reports\n2. Verify table rendering with various data structures\n3. Test the report generation flow and loading states for all report types\n4. Verify error handling and retry functionality\n5. Test responsive design for tables on different screen sizes\n6. Verify navigation between dashboard and reports\n7. Test with actual API responses from the AI/LLM module\n8. Verify the visual styling matches the design requirements\n9. Test device and group selection dropdowns\n10. Verify device comparison table in group and consolidated reports\n11. Test efficiency color coding in the comparison table",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "Implement Data Visualization Components",
        "description": "Create interactive chart components for the Vue.js frontend to visualize power consumption and environmental data trends over time.",
        "details": "1. Create a PowerChart.vue component for displaying electric power consumption:\n```vue\n<template>\n  <div class=\"chart-container\">\n    <h3>Electric Power Consumption</h3>\n    <div class=\"controls\">\n      <select v-model=\"timeRange\" @change=\"fetchData\">\n        <option value=\"day\">Last 24 Hours</option>\n        <option value=\"week\">Last Week</option>\n        <option value=\"month\">Last Month</option>\n      </select>\n    </div>\n    <Line\n      v-if=\"chartData\"\n      :data=\"chartData\"\n      :options=\"chartOptions\"\n    />\n    <div v-else class=\"loading\">Loading data...</div>\n  </div>\n</template>\n\n<script>\nimport { Line } from 'vue-chart-3';\nimport { Chart, registerables } from 'chart.js';\nimport api from '../services/api';\nimport moment from 'moment';\n\nChart.register(...registerables);\n\nexport default {\n  name: 'PowerChart',\n  components: {\n    Line\n  },\n  data() {\n    return {\n      timeRange: 'day',\n      powerData: [],\n      chartData: null,\n      chartOptions: {\n        responsive: true,\n        maintainAspectRatio: false,\n        scales: {\n          y: {\n            beginAtZero: true,\n            title: {\n              display: true,\n              text: 'Power (W)'\n            }\n          },\n          x: {\n            title: {\n              display: true,\n              text: 'Time'\n            }\n          }\n        }\n      }\n    };\n  },\n  mounted() {\n    this.fetchData();\n    // Refresh data every minute\n    this.refreshInterval = setInterval(() => {\n      this.fetchData();\n    }, 60000);\n  },\n  beforeUnmount() {\n    clearInterval(this.refreshInterval);\n  },\n  methods: {\n    async fetchData() {\n      try {\n        const response = await api.getPowerData({ timeRange: this.timeRange });\n        this.powerData = response.data;\n        this.updateChartData();\n      } catch (error) {\n        console.error('Error fetching power data:', error);\n      }\n    },\n    updateChartData() {\n      const labels = this.powerData.map(item => {\n        return moment(item.timestamp).format('MM/DD HH:mm');\n      });\n      \n      const electricData = this.powerData.map(item => item.electric);\n      \n      this.chartData = {\n        labels,\n        datasets: [\n          {\n            label: 'Electric Power (W)',\n            backgroundColor: 'rgba(75, 192, 192, 0.2)',\n            borderColor: 'rgba(75, 192, 192, 1)',\n            borderWidth: 1,\n            data: electricData\n          }\n        ]\n      };\n    }\n  }\n};\n</script>\n\n<style scoped>\n.chart-container {\n  height: 400px;\n  margin-bottom: 20px;\n}\n\n.controls {\n  margin-bottom: 10px;\n  text-align: right;\n}\n\nselect {\n  padding: 5px;\n  border-radius: 4px;\n}\n\n.loading {\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  height: 300px;\n  font-style: italic;\n  color: #666;\n}\n</style>\n```\n\n2. Create an EnvironmentalChart.vue component for temperature, humidity, and brightness:\n```vue\n<template>\n  <div class=\"chart-container\">\n    <h3>{{ title }}</h3>\n    <div class=\"controls\">\n      <select v-model=\"timeRange\" @change=\"fetchData\">\n        <option value=\"day\">Last 24 Hours</option>\n        <option value=\"week\">Last Week</option>\n        <option value=\"month\">Last Month</option>\n      </select>\n    </div>\n    <Line\n      v-if=\"chartData\"\n      :data=\"chartData\"\n      :options=\"chartOptions\"\n    />\n    <div v-else class=\"loading\">Loading data...</div>\n  </div>\n</template>\n\n<script>\nimport { Line } from 'vue-chart-3';\nimport { Chart, registerables } from 'chart.js';\nimport api from '../services/api';\nimport moment from 'moment';\n\nChart.register(...registerables);\n\nexport default {\n  name: 'EnvironmentalChart',\n  components: {\n    Line\n  },\n  props: {\n    dataType: {\n      type: String,\n      required: true,\n      validator: value => ['temperature', 'humidity', 'brightness'].includes(value)\n    },\n    title: {\n      type: String,\n      required: true\n    },\n    color: {\n      type: String,\n      default: 'rgba(75, 192, 192, 1)'\n    },\n    unit: {\n      type: String,\n      required: true\n    }\n  },\n  data() {\n    return {\n      timeRange: 'day',\n      envData: [],\n      chartData: null,\n      chartOptions: {\n        responsive: true,\n        maintainAspectRatio: false,\n        scales: {\n          y: {\n            beginAtZero: false,\n            title: {\n              display: true,\n              text: this.unit\n            }\n          },\n          x: {\n            title: {\n              display: true,\n              text: 'Time'\n            }\n          }\n        }\n      }\n    };\n  },\n  mounted() {\n    this.fetchData();\n    // Refresh data every minute\n    this.refreshInterval = setInterval(() => {\n      this.fetchData();\n    }, 60000);\n  },\n  beforeUnmount() {\n    clearInterval(this.refreshInterval);\n  },\n  methods: {\n    async fetchData() {\n      try {\n        const response = await api.getPowerData({ \n          timeRange: this.timeRange,\n          fields: [this.dataType, 'timestamp']\n        });\n        this.envData = response.data;\n        this.updateChartData();\n      } catch (error) {\n        console.error(`Error fetching ${this.dataType} data:`, error);\n      }\n    },\n    updateChartData() {\n      const labels = this.envData.map(item => {\n        return moment(item.timestamp).format('MM/DD HH:mm');\n      });\n      \n      const data = this.envData.map(item => item[this.dataType]);\n      \n      this.chartData = {\n        labels,\n        datasets: [\n          {\n            label: `${this.title} (${this.unit})`,\n            backgroundColor: `${this.color}33`,\n            borderColor: this.color,\n            borderWidth: 1,\n            data: data\n          }\n        ]\n      };\n    }\n  }\n};\n</script>\n\n<style scoped>\n.chart-container {\n  height: 300px;\n  margin-bottom: 20px;\n}\n\n.controls {\n  margin-bottom: 10px;\n  text-align: right;\n}\n\nselect {\n  padding: 5px;\n  border-radius: 4px;\n}\n\n.loading {\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  height: 200px;\n  font-style: italic;\n  color: #666;\n}\n</style>\n```\n\n3. Create a CurrentPowerDisplay.vue component for prominently showing current power consumption:\n```vue\n<template>\n  <div class=\"current-power\">\n    <h2>Current Power Consumption</h2>\n    <div class=\"power-value\" :class=\"powerClass\">\n      {{ currentPower }} <span class=\"unit\">W</span>\n    </div>\n    <div class=\"timestamp\">Last updated: {{ lastUpdated }}</div>\n  </div>\n</template>\n\n<script>\nimport api from '../services/api';\nimport moment from 'moment';\n\nexport default {\n  name: 'CurrentPowerDisplay',\n  data() {\n    return {\n      currentPower: '---',\n      lastUpdated: '---',\n      refreshInterval: null\n    };\n  },\n  computed: {\n    powerClass() {\n      const power = parseFloat(this.currentPower);\n      if (isNaN(power)) return '';\n      \n      if (power > 1500) return 'high';\n      if (power > 800) return 'medium';\n      return 'low';\n    }\n  },\n  mounted() {\n    this.fetchCurrentPower();\n    // Refresh every 10 seconds\n    this.refreshInterval = setInterval(() => {\n      this.fetchCurrentPower();\n    }, 10000);\n  },\n  beforeUnmount() {\n    clearInterval(this.refreshInterval);\n  },\n  methods: {\n    async fetchCurrentPower() {\n      try {\n        const response = await api.getPowerData({ limit: 1 });\n        if (response.data && response.data.length > 0) {\n          const latestReading = response.data[0];\n          this.currentPower = latestReading.electric.toFixed(1);\n          this.lastUpdated = moment(latestReading.timestamp).format('YYYY-MM-DD HH:mm:ss');\n        }\n      } catch (error) {\n        console.error('Error fetching current power:', error);\n      }\n    }\n  }\n};\n</script>\n\n<style scoped>\n.current-power {\n  text-align: center;\n  padding: 20px;\n  background-color: #f5f5f5;\n  border-radius: 8px;\n  margin-bottom: 20px;\n}\n\n.power-value {\n  font-size: 3rem;\n  font-weight: bold;\n  margin: 10px 0;\n}\n\n.unit {\n  font-size: 1.5rem;\n  color: #666;\n}\n\n.timestamp {\n  font-size: 0.8rem;\n  color: #666;\n}\n\n.low {\n  color: #4CAF50;\n}\n\n.medium {\n  color: #FF9800;\n}\n\n.high {\n  color: #F44336;\n}\n</style>\n```\n\n4. Update the Home.vue view to include all visualization components:\n```vue\n<template>\n  <div class=\"home\">\n    <CurrentPowerDisplay />\n    \n    <div class=\"charts-container\">\n      <PowerChart />\n      \n      <div class=\"env-charts\">\n        <EnvironmentalChart \n          dataType=\"temperature\" \n          title=\"Temperature\" \n          unit=\"°C\" \n          color=\"rgba(255, 99, 132, 1)\" \n        />\n        \n        <EnvironmentalChart \n          dataType=\"humidity\" \n          title=\"Humidity\" \n          unit=\"%\" \n          color=\"rgba(54, 162, 235, 1)\" \n        />\n        \n        <EnvironmentalChart \n          dataType=\"brightness\" \n          title=\"Brightness\" \n          unit=\"lux\" \n          color=\"rgba(255, 206, 86, 1)\" \n        />\n      </div>\n    </div>\n  </div>\n</template>\n\n<script>\nimport CurrentPowerDisplay from '../components/CurrentPowerDisplay.vue';\nimport PowerChart from '../components/PowerChart.vue';\nimport EnvironmentalChart from '../components/EnvironmentalChart.vue';\n\nexport default {\n  name: 'Home',\n  components: {\n    CurrentPowerDisplay,\n    PowerChart,\n    EnvironmentalChart\n  }\n};\n</script>\n\n<style scoped>\n.home {\n  padding: 20px;\n  max-width: 1200px;\n  margin: 0 auto;\n}\n\n.charts-container {\n  margin-top: 20px;\n}\n\n.env-charts {\n  display: grid;\n  grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));\n  gap: 20px;\n  margin-top: 20px;\n}\n\n@media (max-width: 768px) {\n  .env-charts {\n    grid-template-columns: 1fr;\n  }\n}\n</style>\n```",
        "testStrategy": "1. Test each chart component with mock data\n2. Verify chart rendering with various data sets\n3. Test time range selection functionality\n4. Verify data refresh mechanism\n5. Test responsive design on different screen sizes\n6. Verify color coding for current power display\n7. Test with actual API responses\n8. Verify error handling for API failures\n9. Test performance with large datasets\n10. Verify accessibility of chart components",
        "priority": "high",
        "dependencies": [
          6
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "System Integration and Testing",
        "description": "Integrate all components, perform end-to-end testing, and ensure the complete system works as expected with real data flow from MQTT to visualization, with special focus on multi-device scenarios.",
        "status": "pending",
        "dependencies": [
          3,
          4,
          5,
          6,
          7,
          8,
          9
        ],
        "priority": "high",
        "details": "1. Create a test plan document covering:\n   - MQTT message publishing and subscription from multiple devices\n   - Database storage and retrieval for multi-device data\n   - API endpoints functionality for device-specific and aggregated data\n   - Frontend visualization for multiple devices\n   - ESG report generation for single devices and device groups\n   - End-to-end data flow in multi-device scenarios\n\n2. Set up a test environment with:\n   - MQTT test clients simulating multiple ESP32 devices\n   - Database inspection tools\n   - API testing tools (e.g., Postman)\n   - Browser for frontend testing\n\n3. Implement test scripts for automated testing:\n   - MQTT publish scripts to simulate multiple ESP32 devices\n   - API endpoint tests for device-specific and aggregated data\n   - Database query tests for multi-device scenarios\n\n4. Test the complete data flow:\n   - Publish sample MQTT messages from multiple devices with the specified JSON format\n   - Verify device-specific data is stored correctly in MySQL\n   - Check API endpoints return expected data for individual and multiple devices\n   - Verify frontend displays data correctly for all devices\n   - Test ESG report generation for individual devices and device groups\n\n5. Test error handling and edge cases:\n   - Network interruptions affecting specific devices\n   - Malformed MQTT messages from specific devices\n   - Database connection issues\n   - API failures\n   - Missing or incomplete data from specific devices\n   - Device disconnection and reconnection scenarios\n\n6. Performance testing:\n   - Test with high-frequency messages from multiple devices simultaneously\n   - Verify system stability with many devices connected over extended periods\n   - Check database performance with growing data volume from multiple devices\n   - Test system responsiveness when visualizing data from many devices\n\n7. Create a sample multi-device MQTT publish script for testing:\n```python\n#!/usr/bin/env python3\nimport paho.mqtt.client as mqtt\nimport json\nimport time\nimport datetime\nimport random\nimport threading\n\n# MQTT broker settings\nbroker = \"localhost\"\nport = 1883\ntopic = \"power/measurements\"\n\ndef device_simulation(device_code):\n    # Connect to MQTT broker\n    client = mqtt.Client(f\"device-{device_code}\")\n    client.connect(broker, port, 60)\n    \n    try:\n        while True:\n            # Generate sample data\n            data = {\n                \"deviceCode\": device_code,\n                \"timestamp\": datetime.datetime.utcnow().strftime(\"%Y-%m-%dT%H:%M:%SZ\"),\n                \"temp\": round(random.uniform(20.0, 30.0), 1),\n                \"humidity\": round(random.uniform(40.0, 80.0), 1),\n                \"brightness\": random.randint(200, 1000),\n                \"electric\": round(random.uniform(500, 1500), 1)\n            }\n            \n            # Convert to JSON and publish\n            payload = json.dumps(data)\n            client.publish(topic, payload)\n            print(f\"Device {device_code} published: {payload}\")\n            \n            # Wait random time between 5-10 seconds to simulate real-world variation\n            time.sleep(random.uniform(5, 10))\n            \n    except Exception as e:\n        print(f\"Device {device_code} error: {e}\")\n    finally:\n        client.disconnect()\n\n# Simulate multiple devices\ndevice_codes = [101, 102, 103, 104, 105]  # Example device codes\nthreads = []\n\ntry:\n    # Start a thread for each device\n    for device_code in device_codes:\n        thread = threading.Thread(target=device_simulation, args=(device_code,))\n        thread.daemon = True\n        thread.start()\n        threads.append(thread)\n        print(f\"Started simulation for device {device_code}\")\n    \n    # Keep the main thread alive\n    while True:\n        time.sleep(1)\n        \nexcept KeyboardInterrupt:\n    print(\"Stopped by user\")\n```\n\n8. Create an enhanced system health check script with multi-device support:\n```python\n#!/usr/bin/env python3\nimport requests\nimport mysql.connector\nimport paho.mqtt.client as mqtt\nimport json\nimport time\nimport sys\n\ndef check_mqtt():\n    try:\n        # Try to connect to MQTT broker\n        client = mqtt.Client()\n        client.connect(\"localhost\", 1883, 5)\n        client.disconnect()\n        print(\"✅ MQTT broker is running\")\n        return True\n    except Exception as e:\n        print(f\"❌ MQTT broker check failed: {e}\")\n        return False\n\ndef check_mysql():\n    try:\n        # Try to connect to MySQL\n        conn = mysql.connector.connect(\n            host=\"localhost\",\n            user=\"power_user\",\n            password=\"secure_password\",\n            database=\"power_measurement\"\n        )\n        cursor = conn.cursor()\n        cursor.execute(\"SELECT COUNT(*) FROM power_readings\")\n        result = cursor.fetchone()\n        print(f\"✅ MySQL is running. Total records: {result[0]}\")\n        \n        # Check device-specific data\n        cursor.execute(\"SELECT deviceCode, COUNT(*) FROM power_readings GROUP BY deviceCode\")\n        devices = cursor.fetchall()\n        for device, count in devices:\n            print(f\"  - Device {device}: {count} records\")\n            \n        cursor.close()\n        conn.close()\n        return True\n    except Exception as e:\n        print(f\"❌ MySQL check failed: {e}\")\n        return False\n\ndef check_flask_api():\n    try:\n        # Try to connect to Flask API\n        response = requests.get(\"http://localhost:5000/api/power_data?limit=1\")\n        response.raise_for_status()\n        print(\"✅ Flask API is running\")\n        \n        # Check device-specific endpoints\n        devices_response = requests.get(\"http://localhost:5000/api/devices\")\n        devices_response.raise_for_status()\n        devices = devices_response.json()\n        print(f\"  - Found {len(devices)} devices in the system\")\n        \n        return True\n    except Exception as e:\n        print(f\"❌ Flask API check failed: {e}\")\n        return False\n\ndef check_vue_frontend():\n    try:\n        # Try to connect to Vue frontend\n        response = requests.get(\"http://localhost\")\n        response.raise_for_status()\n        print(\"✅ Vue frontend is running\")\n        return True\n    except Exception as e:\n        print(f\"❌ Vue frontend check failed: {e}\")\n        return False\n\ndef main():\n    print(\"System Health Check\")\n    print(\"-----------------\")\n    \n    mqtt_ok = check_mqtt()\n    mysql_ok = check_mysql()\n    api_ok = check_flask_api()\n    frontend_ok = check_vue_frontend()\n    \n    all_ok = mqtt_ok and mysql_ok and api_ok and frontend_ok\n    \n    print(\"-----------------\")\n    if all_ok:\n        print(\"✅ All systems operational\")\n        return 0\n    else:\n        print(\"❌ Some systems are not operational\")\n        return 1\n\nif __name__ == \"__main__\":\n    sys.exit(main())\n```\n\n9. Document the testing process and results, including multi-device scenarios\n\n10. Create a deployment checklist for the production environment with multi-device support\n\n11. Test device management functionality:\n   - Device registration and onboarding\n   - Device grouping and categorization\n   - Device status monitoring\n   - Device configuration updates\n\n12. Test multi-device visualization features:\n   - Device comparison charts\n   - Aggregated data views\n   - Device filtering and selection\n   - Group-based visualizations",
        "testStrategy": "1. Verify MQTT message flow from multiple test clients to Flask backend\n2. Test database storage with various message formats from different devices\n3. Verify API endpoints return correct data for individual devices and device groups\n4. Test frontend visualization with real-time data from multiple devices\n5. Verify ESG report generation with actual data for individual devices and device groups\n6. Test system resilience to network interruptions affecting specific devices\n7. Verify data integrity during component restarts with multiple connected devices\n8. Test system performance under load with many devices sending data simultaneously\n9. Verify all error handling mechanisms for multi-device scenarios\n10. Test device management functionality including registration, grouping, and status monitoring\n11. Verify multi-device visualization features including comparison charts and aggregated views\n12. Conduct user acceptance testing with sample personas managing multiple devices",
        "subtasks": []
      },
      {
        "id": 11,
        "title": "Extend MySQL Schema with Devices Table and Relationships",
        "description": "Add a new 'devices' table to the MySQL database to manage multiple device records, including device metadata, and establish a foreign key relationship with the existing 'power_readings' table.",
        "details": "1. Design and implement a 'devices' table with the following columns: device_code (VARCHAR, unique, stores MAC address), device_name (VARCHAR), location (VARCHAR), device_group (VARCHAR), status (ENUM or VARCHAR), last_seen (DATETIME), created_at (TIMESTAMP, default CURRENT_TIMESTAMP), and updated_at (TIMESTAMP, auto-updated on modification).\n2. Use InnoDB as the storage engine to support foreign key constraints and transactional integrity, following current best practices for relational IoT data management.\n3. Ensure 'device_code' is the primary key for the 'devices' table and matches the type used in 'power_readings'.\n4. Alter the 'power_readings' table to change 'device_code' to match the type (e.g., VARCHAR(17) for MAC addresses) if necessary, and add a foreign key constraint referencing 'devices(device_code)' to enforce referential integrity.\n5. Update the database initialization SQL scripts (e.g., init.sql) to include the new table creation and relationship setup, ensuring idempotency with 'IF NOT EXISTS' and 'ON UPDATE CASCADE, ON DELETE SET NULL' or similar options for the foreign key.\n6. Document the schema changes and update any relevant ORM models or database access code in the backend application to reflect the new structure.\n7. Consider indexing 'last_seen' and 'status' for efficient querying of active or recently seen devices.",
        "testStrategy": "1. Run the updated SQL schema scripts on a test MySQL instance and verify successful creation of the 'devices' table and foreign key relationship.\n2. Insert sample device records and verify that 'power_readings' entries with matching 'device_code' are accepted, while invalid codes are rejected.\n3. Test ON DELETE and ON UPDATE actions for the foreign key to ensure correct cascading or nullification behavior.\n4. Query the 'devices' table for filtering by status, device_group, and last_seen to confirm index effectiveness.\n5. Update backend code to fetch device metadata alongside power readings and verify via API or direct queries.\n6. Review and update documentation to reflect the new schema and relationships.",
        "status": "pending",
        "dependencies": [
          4
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 12,
        "title": "Implement Multi-Device Management API Endpoints in Flask Backend",
        "description": "Add new API endpoints to the Flask backend for managing multiple devices, including device listing, registration, power data retrieval, ESG reporting, and device comparison.",
        "details": "1. Update the Flask application structure to include new routes:\n\n```python\nfrom flask import Flask, request, jsonify\nfrom flask_restful import Api, Resource\nfrom models import Device, PowerReading\nfrom database import db\n\napp = Flask(__name__)\napi = Api(app)\n\nclass DeviceList(Resource):\n    def get(self):\n        # Implement device listing logic\n    def post(self):\n        # Implement device registration logic\n\nclass DevicePowerData(Resource):\n    def get(self, device_code):\n        # Implement power data retrieval logic\n\nclass DeviceESGReport(Resource):\n    def get(self, device_code):\n        # Implement ESG report generation logic\n\nclass DeviceComparison(Resource):\n    def post(self):\n        # Implement device comparison logic\n\napi.add_resource(DeviceList, '/api/devices')\napi.add_resource(DevicePowerData, '/api/devices/<string:device_code>/power_data')\napi.add_resource(DeviceESGReport, '/api/devices/<string:device_code>/esg_report')\napi.add_resource(DeviceComparison, '/api/devices/compare')\n```\n\n2. Implement the DeviceList resource:\n```python\nclass DeviceList(Resource):\n    def get(self):\n        devices = Device.query.all()\n        return jsonify([device.to_dict() for device in devices])\n\n    def post(self):\n        data = request.get_json()\n        new_device = Device(\n            device_code=data['device_code'],\n            device_name=data['device_name'],\n            location=data.get('location'),\n            device_group=data.get('device_group'),\n            status='active'\n        )\n        db.session.add(new_device)\n        db.session.commit()\n        return jsonify(new_device.to_dict()), 201\n```\n\n3. Implement the DevicePowerData resource:\n```python\nclass DevicePowerData(Resource):\n    def get(self, device_code):\n        device = Device.query.filter_by(device_code=device_code).first_or_404()\n        power_readings = PowerReading.query.filter_by(device_code=device_code).order_by(PowerReading.timestamp.desc()).limit(100).all()\n        return jsonify([reading.to_dict() for reading in power_readings])\n```\n\n4. Implement the DeviceESGReport resource:\n```python\nfrom ai_llm_module import generate_esg_report\n\nclass DeviceESGReport(Resource):\n    def get(self, device_code):\n        device = Device.query.filter_by(device_code=device_code).first_or_404()\n        power_readings = PowerReading.query.filter_by(device_code=device_code).order_by(PowerReading.timestamp.desc()).limit(1000).all()\n        esg_report = generate_esg_report(device, power_readings)\n        return jsonify(esg_report)\n```\n\n5. Implement the DeviceComparison resource:\n```python\nclass DeviceComparison(Resource):\n    def post(self):\n        data = request.get_json()\n        device_codes = data.get('device_codes', [])\n        if not device_codes:\n            return jsonify({\"error\": \"No device codes provided\"}), 400\n\n        devices = Device.query.filter(Device.device_code.in_(device_codes)).all()\n        if len(devices) != len(device_codes):\n            return jsonify({\"error\": \"One or more device codes are invalid\"}), 400\n\n        comparison_data = {}\n        for device in devices:\n            power_readings = PowerReading.query.filter_by(device_code=device.device_code).order_by(PowerReading.timestamp.desc()).limit(100).all()\n            comparison_data[device.device_code] = {\n                \"device_name\": device.device_name,\n                \"average_power\": sum(r.electric for r in power_readings) / len(power_readings) if power_readings else 0,\n                \"total_power\": sum(r.electric for r in power_readings),\n                \"last_reading\": power_readings[0].to_dict() if power_readings else None\n            }\n\n        return jsonify(comparison_data)\n```\n\n6. Implement automatic device registration:\n   - Create a background task that listens to MQTT messages for new device connections.\n   - When a new device is detected, automatically add it to the database if it doesn't exist.\n\n```python\nimport paho.mqtt.client as mqtt\nfrom models import Device\nfrom database import db\n\ndef on_connect(client, userdata, flags, rc):\n    client.subscribe(\"devices/+/status\")\n\ndef on_message(client, userdata, msg):\n    device_code = msg.topic.split('/')[1]\n    device = Device.query.filter_by(device_code=device_code).first()\n    if not device:\n        new_device = Device(device_code=device_code, status='active')\n        db.session.add(new_device)\n        db.session.commit()\n\nclient = mqtt.Client()\nclient.on_connect = on_connect\nclient.on_message = on_message\nclient.connect(\"mosquitto\", 1883, 60)\nclient.loop_start()\n```\n\n7. Update the main Flask application to include CORS support and error handling:\n\n```python\nfrom flask_cors import CORS\n\napp = Flask(__name__)\nCORS(app)\n\n@app.errorhandler(404)\ndef not_found(error):\n    return jsonify({\"error\": \"Not found\"}), 404\n\n@app.errorhandler(500)\ndef internal_error(error):\n    return jsonify({\"error\": \"Internal server error\"}), 500\n```\n\n8. Ensure proper authentication and authorization mechanisms are in place for all API endpoints.\n\n9. Implement rate limiting to prevent API abuse:\n\n```python\nfrom flask_limiter import Limiter\nfrom flask_limiter.util import get_remote_address\n\nlimiter = Limiter(\n    app,\n    key_func=get_remote_address,\n    default_limits=[\"200 per day\", \"50 per hour\"]\n)\n```\n\n10. Add comprehensive logging for all API operations:\n\n```python\nimport logging\nfrom logging.handlers import RotatingFileHandler\n\nhandler = RotatingFileHandler('app.log', maxBytes=10000, backupCount=3)\nhandler.setLevel(logging.INFO)\napp.logger.addHandler(handler)\n\n@app.after_request\ndef after_request(response):\n    app.logger.info(f\"{request.remote_addr} {request.method} {request.url} {response.status}\")\n    return response\n```",
        "testStrategy": "1. Unit Testing:\n   - Write unit tests for each API endpoint using pytest.\n   - Test each endpoint with various input scenarios, including valid and invalid data.\n   - Mock database calls and external services (like the AI/LLM module) for isolated testing.\n\n2. Integration Testing:\n   - Set up a test database with sample device and power reading data.\n   - Test the API endpoints with actual database interactions.\n   - Verify that the automatic device registration works correctly with simulated MQTT messages.\n\n3. API Testing:\n   - Use tools like Postman or curl to test all API endpoints manually.\n   - Create a collection of API tests that can be run automatically.\n   - Test pagination, filtering, and sorting for the device list endpoint.\n\n4. Performance Testing:\n   - Use tools like Apache JMeter or Locust to simulate high load on the API.\n   - Verify that rate limiting is working as expected.\n   - Test the performance of device comparison with a large number of devices.\n\n5. Security Testing:\n   - Perform penetration testing on all API endpoints.\n   - Verify that authentication and authorization are working correctly.\n   - Test for common vulnerabilities like SQL injection, XSS, and CSRF.\n\n6. Error Handling:\n   - Test all error scenarios to ensure proper error messages are returned.\n   - Verify that the application logs errors correctly.\n\n7. CORS Testing:\n   - Test API access from different origins to ensure CORS is configured correctly.\n\n8. Automated Testing:\n   - Set up a CI/CD pipeline that runs all tests automatically on each commit.\n   - Include both unit and integration tests in the automated test suite.\n\n9. User Acceptance Testing:\n   - Provide a test environment for end-users to interact with the API.\n   - Collect feedback on API usability and functionality.\n\n10. Documentation Testing:\n    - Verify that API documentation (e.g., Swagger) is up-to-date and accurate.\n    - Test all example requests provided in the documentation.\n\n11. Long-running Tests:\n    - Set up tests that run for extended periods to catch memory leaks or performance degradation over time.\n\n12. Compatibility Testing:\n    - Test the API with different client libraries and programming languages.\n    - Verify compatibility with older versions of client applications, if applicable.",
        "status": "pending",
        "dependencies": [
          11,
          4,
          7
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 13,
        "title": "Implement Multi-Device Management Interface in Vue.js Frontend",
        "description": "Develop a DeviceManager component in Vue.js to implement a multi-device management interface, including device selection dropdown, status display, grouping, and filtering functionality, and integrate it with the existing dashboard.",
        "details": "1. Create a new Vue.js component named DeviceManager.vue in the src/components directory:\n\n```vue\n<template>\n  <div class=\"device-manager\">\n    <h2>Device Management</h2>\n    \n    <!-- Device selection dropdown -->\n    <select v-model=\"selectedDevice\" @change=\"onDeviceSelect\">\n      <option v-for=\"device in devices\" :key=\"device.code\" :value=\"device.code\">\n        {{ device.name }}\n      </option>\n    </select>\n\n    <!-- Device status display -->\n    <div class=\"device-status\">\n      <span :class=\"['status-indicator', selectedDevice.status]\"></span>\n      {{ selectedDevice.status }}\n    </div>\n\n    <!-- Device grouping -->\n    <div class=\"device-groups\">\n      <h3>Device Groups</h3>\n      <ul>\n        <li v-for=\"group in deviceGroups\" :key=\"group\">\n          <a @click=\"filterByGroup(group)\">{{ group }}</a>\n        </li>\n      </ul>\n    </div>\n\n    <!-- Device filtering -->\n    <div class=\"device-filters\">\n      <input v-model=\"searchQuery\" placeholder=\"Search devices...\">\n      <select v-model=\"statusFilter\">\n        <option value=\"\">All Statuses</option>\n        <option value=\"online\">Online</option>\n        <option value=\"offline\">Offline</option>\n      </select>\n    </div>\n\n    <!-- Device list -->\n    <ul class=\"device-list\">\n      <li v-for=\"device in filteredDevices\" :key=\"device.code\">\n        {{ device.name }} - {{ device.status }}\n      </li>\n    </ul>\n  </div>\n</template>\n\n<script>\nimport { ref, computed, onMounted } from 'vue';\nimport axios from 'axios';\n\nexport default {\n  name: 'DeviceManager',\n  setup() {\n    const devices = ref([]);\n    const selectedDevice = ref(null);\n    const searchQuery = ref('');\n    const statusFilter = ref('');\n\n    const fetchDevices = async () => {\n      try {\n        const response = await axios.get('/api/devices');\n        devices.value = response.data;\n      } catch (error) {\n        console.error('Error fetching devices:', error);\n      }\n    };\n\n    onMounted(fetchDevices);\n\n    const deviceGroups = computed(() => {\n      return [...new Set(devices.value.map(device => device.group))];\n    });\n\n    const filteredDevices = computed(() => {\n      return devices.value.filter(device => {\n        const matchesSearch = device.name.toLowerCase().includes(searchQuery.value.toLowerCase());\n        const matchesStatus = !statusFilter.value || device.status === statusFilter.value;\n        return matchesSearch && matchesStatus;\n      });\n    });\n\n    const onDeviceSelect = () => {\n      // Implement logic to update selected device data\n    };\n\n    const filterByGroup = (group) => {\n      // Implement logic to filter devices by group\n    };\n\n    return {\n      devices,\n      selectedDevice,\n      searchQuery,\n      statusFilter,\n      deviceGroups,\n      filteredDevices,\n      onDeviceSelect,\n      filterByGroup\n    };\n  }\n}\n</script>\n\n<style scoped>\n/* Add appropriate styles for the component */\n</style>\n```\n\n2. Update the main dashboard component (e.g., Dashboard.vue) to include the DeviceManager component:\n\n```vue\n<template>\n  <div class=\"dashboard\">\n    <h1>Power Monitoring Dashboard</h1>\n    <DeviceManager />\n    <!-- Other existing dashboard components -->\n  </div>\n</template>\n\n<script>\nimport DeviceManager from '@/components/DeviceManager.vue';\n\nexport default {\n  name: 'Dashboard',\n  components: {\n    DeviceManager,\n    // Other existing components\n  },\n  // ... existing dashboard logic\n}\n</script>\n```\n\n3. Implement the necessary API calls in the DeviceManager component to fetch device data from the Flask backend. Use the axios library for HTTP requests.\n\n4. Implement real-time updates for device status using WebSocket connections or polling, depending on the backend implementation.\n\n5. Optimize the component for performance, especially when dealing with a large number of devices:\n   - Implement pagination or infinite scrolling for the device list\n   - Use Vue's virtual scrolling for large lists (vue-virtual-scroller)\n\n6. Implement error handling and loading states for API calls and data fetching.\n\n7. Ensure the component is responsive and works well on different screen sizes, including mobile devices.\n\n8. Implement accessibility features such as proper ARIA attributes and keyboard navigation.\n\n9. Add unit tests for the DeviceManager component using Vue Test Utils and Jest.\n\n10. Integrate the DeviceManager component with the existing power consumption charts and ESG report display, allowing users to view data for specific devices or groups.",
        "testStrategy": "1. Unit Testing:\n   - Write unit tests for the DeviceManager component using Vue Test Utils and Jest\n   - Test the component's reactivity and computed properties\n   - Mock API calls and test different data scenarios\n   - Verify filtering and grouping functionality\n   - Test error handling and loading states\n\n2. Integration Testing:\n   - Integrate the DeviceManager component into the main dashboard\n   - Verify that it interacts correctly with other components\n   - Test the flow of data between the DeviceManager and other parts of the application\n\n3. End-to-End Testing:\n   - Use a tool like Cypress to perform end-to-end tests\n   - Simulate user interactions with the DeviceManager interface\n   - Verify that device selection, filtering, and grouping work as expected\n   - Test the responsiveness of the component on different screen sizes\n\n4. Performance Testing:\n   - Test the component's performance with a large number of devices\n   - Verify that pagination or infinite scrolling works efficiently\n   - Use browser developer tools to check for any performance bottlenecks\n\n5. Accessibility Testing:\n   - Use automated tools like axe-core to check for accessibility issues\n   - Perform manual testing with screen readers and keyboard navigation\n\n6. Cross-browser Testing:\n   - Test the component on different browsers (Chrome, Firefox, Safari, Edge)\n   - Verify consistent functionality and appearance across browsers\n\n7. Mobile Testing:\n   - Test the component on various mobile devices and tablets\n   - Verify touch interactions and responsive design\n\n8. API Integration Testing:\n   - Test the integration with the Flask backend API\n   - Verify correct handling of API responses and error states\n\n9. Real-time Update Testing:\n   - Test the real-time update functionality for device status changes\n   - Verify that WebSocket connections or polling mechanisms work correctly\n\n10. User Acceptance Testing:\n    - Conduct user testing sessions to gather feedback on usability and functionality\n    - Make necessary adjustments based on user feedback",
        "status": "pending",
        "dependencies": [
          12,
          9,
          6
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 14,
        "title": "Develop Multi-Device Data Comparison and Visualization Components",
        "description": "Implement MultiDeviceChart and DeviceComparison Vue.js components to enable simultaneous comparison and visualization of power, temperature, humidity, and brightness data from multiple devices, including real-time updates and an integrated dashboard view.",
        "details": "1. Create two new Vue.js components: MultiDeviceChart.vue and DeviceComparison.vue in the src/components directory. \n2. Use Chart.js (via vue-chartjs) or ECharts for rendering multi-axis, multi-series charts that can display power consumption, temperature, humidity, and brightness for several devices concurrently. Configure multiple value axes as needed for different units and scales[1][2].\n3. Design the components to accept dynamic device selection (from DeviceManager) and fetch corresponding data via API endpoints (from the Flask backend). Support both historical and real-time data using Vue's reactivity and watchers to update charts as new data arrives[3].\n4. Implement a dashboard layout that allows users to select devices, compare their metrics side-by-side, and view aggregated trends. Provide controls for time range selection, device grouping, and metric toggling.\n5. Ensure accessibility and responsive design for usability across devices. Use color coding and legends for clarity. \n6. Optimize performance for large datasets by leveraging chart library features such as data decimation and lazy rendering. \n7. Integrate error handling for API failures and empty data states. \n8. Document component props, events, and usage patterns for maintainability.",
        "testStrategy": "1. Unit test each component using Vue Test Utils and Jest: verify correct rendering with mock data, prop reactivity, and event handling. \n2. Test chart rendering with multiple devices and metrics, ensuring axes and legends are accurate. \n3. Simulate real-time data updates and confirm charts update without full reloads. \n4. Perform integration tests with the DeviceManager and backend API endpoints, mocking API responses for various scenarios (multiple devices, missing data, API errors). \n5. Test dashboard responsiveness and accessibility on different screen sizes and with keyboard navigation. \n6. Validate performance with large datasets and multiple concurrent device streams. \n7. Conduct user acceptance testing for usability and clarity of comparison features.",
        "status": "pending",
        "dependencies": [
          13,
          12,
          9,
          6
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 15,
        "title": "Extend AI/LLM Module for Multi-Device ESG Report Generation",
        "description": "Enhance the AI/LLM module to support ESG report generation across multiple devices, enabling single device, device group, and integrated fleet analysis, including per-device carbon emission calculation, device comparison, and consolidated environmental impact reporting using the Claude API.",
        "details": "1. Refactor the existing AI/LLM module to accept and process data for multiple devices, supporting three analysis modes: single device, device group, and all devices (fleet-wide).\n2. Implement robust data aggregation logic to calculate carbon emissions per device, aggregate by group, and compute total emissions for all devices, following recognized standards for carbon accounting (e.g., GHG Protocol).\n3. Develop comparison algorithms to analyze and visualize differences in carbon emissions and other ESG metrics between devices and groups, leveraging pandas for data manipulation.\n4. Integrate with the Claude API to generate natural language ESG reports that summarize findings, highlight key insights, and provide actionable recommendations for emission reduction.\n5. Design the module interface to accept structured input (e.g., JSON) specifying analysis scope (device, group, all), time range, and reporting preferences.\n6. Ensure the module is stateless and scalable, supporting concurrent report generation requests from the backend API.\n7. Follow best practices for LLM integration: handle API rate limits, implement retries, and sanitize input/output to prevent prompt injection or data leakage.\n8. Document the module's API and provide usage examples for integration with the Flask backend.\n9. Write modular, testable code with clear separation between data processing, LLM interaction, and report formatting.",
        "testStrategy": "1. Unit test data aggregation and carbon calculation logic with diverse multi-device datasets, including edge cases (e.g., missing data, outliers).\n2. Mock Claude API responses to verify correct prompt construction and report formatting for all analysis modes (single, group, fleet).\n3. Perform integration tests with the Flask backend, simulating real-world multi-device scenarios and verifying end-to-end report generation.\n4. Validate that generated reports accurately reflect input data and include required comparative and summary sections.\n5. Conduct performance and concurrency tests to ensure the module handles multiple simultaneous requests efficiently.\n6. Review code for security best practices, including input validation and safe API usage.",
        "status": "pending",
        "dependencies": [
          14,
          7
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 16,
        "title": "Implement Real-Time Device Status Monitoring System with WebSocket Integration",
        "description": "Develop a real-time device status monitoring system using Flask (backend) and Vue.js (frontend) with WebSocket support, enabling online/offline tracking, last data received timestamp, connection status notifications, device performance metric monitoring, and network issue detection and alerts.",
        "details": "1. Backend (Flask):\n- Integrate Flask-SocketIO to provide WebSocket endpoints for real-time communication with the frontend.\n- Maintain an in-memory or persistent store (e.g., Redis) to track each device's online/offline status, last data received timestamp, and performance metrics (e.g., CPU, memory, sensor health).\n- Update device status upon receiving data via MQTT or API, and broadcast status changes to connected WebSocket clients.\n- Implement logic to detect network issues (e.g., missed heartbeats, delayed data) and trigger alerts.\n- Expose REST endpoints for historical status and performance queries as needed.\n\n2. Frontend (Vue.js):\n- Use vue-socket.io or native WebSocket API to connect to the Flask backend and subscribe to device status updates.\n- Extend the DeviceManager and dashboard components to display real-time online/offline status, last data received, and performance metrics for each device.\n- Implement UI notifications (e.g., toast, modal, or banner) for device connection/disconnection events and network issue alerts.\n- Provide visual indicators (e.g., colored icons, timestamps) for device health and connectivity.\n\n3. General:\n- Ensure robust error handling and reconnection logic for WebSocket connections on both backend and frontend.\n- Follow best practices for scalable real-time systems, such as using message queues or pub/sub (e.g., Redis, RabbitMQ) if needed for high device counts.\n- Document the WebSocket API and event payloads for frontend-backend integration.\n\nReferences: Flask-SocketIO documentation, Vue.js WebSocket integration guides, and industry best practices for condition monitoring systems[1][4].",
        "testStrategy": "1. Unit test backend logic for device status tracking, event broadcasting, and network issue detection using pytest and Flask-SocketIO test clients.\n2. Simulate device data streams and network interruptions to verify correct online/offline transitions and alert generation.\n3. Use Vue Test Utils and Jest to test frontend components for real-time status updates, UI notifications, and error handling.\n4. Perform end-to-end tests by simulating multiple devices connecting/disconnecting and verify that the frontend reflects all status changes in real time.\n5. Test WebSocket reconnection and fallback mechanisms under network instability.\n6. Review WebSocket event payloads for completeness and correctness.",
        "status": "pending",
        "dependencies": [
          12,
          13,
          6
        ],
        "priority": "medium",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-06-27T06:38:32.342Z",
      "updated": "2025-08-05T06:53:49.612Z",
      "description": "Tasks for master context"
    }
  }
}